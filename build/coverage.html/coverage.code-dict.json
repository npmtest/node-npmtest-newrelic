{"/home/travis/build/npmtest/node-npmtest-newrelic/test.js":"/* istanbul instrument in package npmtest_newrelic */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-newrelic/lib.npmtest_newrelic.js":"/* istanbul instrument in package npmtest_newrelic */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_newrelic = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_newrelic = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-newrelic/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-newrelic && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_newrelic */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_newrelic\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_newrelic.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_newrelic.rollup.js'] =\n            local.assetsDict['/assets.npmtest_newrelic.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_newrelic.__dirname +\n                    '/lib.npmtest_newrelic.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/index.js":"'use strict'\n\nvar logger = require('./lib/logger.js')\nvar semver = require('semver')\n\nvar message\nvar agent\n\nvar agentVersion = require('./package.json').version\nlogger.info(\n  \"Using New Relic for Node.js. Agent version: %s; Node version: %s.\",\n  agentVersion, process.version\n)\n\nif (require.cache.__NR_cache) {\n  logger.warn(\n    'Attempting to load a second copy of newrelic from %s, using cache instead',\n    __dirname\n  )\n  module.exports = require.cache.__NR_cache\n} else {\n  initialize()\n}\n\nfunction initialize() {\n  logger.debug(\n    'Loading agent from %s',\n    __dirname\n  )\n\n  try {\n    logger.debug(\"Process was running %s seconds before agent was loaded.\",\n                 process.uptime())\n    // Technically we run on 0.6, until we verify there are 0 users on 0.6, we\n    // should leave this code doing a check against 0.6, but then advise that\n    // people upgrade to one of our officially supported version (0.8 and higher)\n    if (semver.satisfies(process.version, '<0.6.0')) {\n      message = \"New Relic for Node.js requires a version of Node equal to or\\n\" +\n                \"greater than 0.8.0. Not starting!\"\n\n      logger.error(message)\n      throw new Error(message)\n    }\n\n    logger.debug(\"Current working directory at module load is %s.\", process.cwd())\n    logger.debug(\"Process title is %s.\", process.title)\n    logger.debug(\"Application was invoked as %s.\", process.argv.join(' '))\n\n    var config = require('./lib/config.js').getOrCreateInstance()\n\n    // Get the initialized logger as we likely have a bootstrap logger which\n    // just pipes to stdout.\n    logger = require('./lib/logger.js')\n\n    if (!config || !config.agent_enabled) {\n      logger.info(\"Module not enabled in configuration; not starting.\")\n    } else {\n      /* Only load the rest of the module if configuration is available and the\n       * configurator didn't throw.\n       *\n       * The agent must be a singleton, or else module loading will be patched\n       * multiple times, with undefined results. New Relic's instrumentation\n       * can't be enabled or disabled without an application restart.\n       */\n      var Agent = require('./lib/agent.js')\n      agent = new Agent(config)\n      var appNames = agent.config.applications()\n\n      if (config.logging.diagnostics) {\n        logger.warn(\n          'Diagnostics logging is enabled, this may cause significant overhead.'\n        )\n      }\n\n      if (appNames.length < 1) {\n        message = \"New Relic requires that you name this application!\\n\" +\n                  \"Set app_name in your newrelic.js file or set environment variable\\n\" +\n                  \"NEW_RELIC_APP_NAME. Not starting!\"\n        logger.error(message)\n        throw new Error(message)\n      }\n\n      var shimmer = require('./lib/shimmer.js')\n      shimmer.patchModule(agent)\n      shimmer.bootstrapInstrumentation(agent)\n\n      agent.start(function cb_start(error) {\n        if (!error) {\n          return logger.debug(\"New Relic for Node.js is connected to New Relic.\")\n        }\n\n        var errorMessage = \"New Relic for Node.js halted startup due to an error:\"\n        logger.error(error, errorMessage)\n\n        console.error(errorMessage)\n        console.error(error.stack)\n      })\n    }\n  } catch (error) {\n    message = \"New Relic for Node.js was unable to bootstrap itself due to an error:\"\n    logger.error(error, message)\n\n    console.error(message)\n    console.error(error.stack)\n  }\n\n  var API\n  if (agent) {\n    API = require('./api.js')\n  } else {\n    API = require('./stub_api.js')\n  }\n\n  require.cache.__NR_cache = module.exports = new API(agent)\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/logger.js":"'use strict'\n\nvar Logger = require('./util/logger')\nvar fs = require('fs')\n\n// create bootstrapping logger\nmodule.exports = new Logger({\n  name: 'newrelic_bootstrap',\n  stream: process.stdout,\n  level: 'info'\n})\n\n/**\n * Don't load config.js until this point, because it requires this\n * module, and if it gets loaded too early, module.exports will have no\n * value.\n */\nvar config = require('./config.js').getOrCreateInstance()\nif (config) {\n  var options = {\n    name: 'newrelic',\n    level: config.logging.level,\n    enabled: config.logging.enabled\n  }\n\n  // create the \"real\" logger\n  module.exports = new Logger(options)\n\n  if (config.logging.enabled) {\n    var stream\n    switch (config.logging.filepath) {\n      case 'stdout':\n        stream = process.stdout\n        break\n\n      case 'stderr':\n        stream = process.stderr\n        break\n\n      default:\n        stream = fs.createWriteStream(config.logging.filepath, {flags: 'a+'})\n        stream.on('error', function logStreamOnError(err) {\n          /* eslint-disable no-console */\n          // Since our normal logging didn't work, dump this to stderr.\n          console.error('New Relic failed to open log file ' + config.logging.filepath)\n          console.error(err)\n          /* eslint-enable no-console */\n        })\n    }\n    module.exports.pipe(stream)\n  }\n\n  // now tell the config module to switch to the real logger\n  config.setLogger(module.exports)\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/util/logger.js":"'use strict'\n\nvar stringifySync = require('./safe-json').stringifySync\nvar util = require('util')\nvar Readable = require('readable-stream')\nvar os = require('os')\n\nmodule.exports = Logger\n\nvar LEVELS = {\n  'trace': 10,\n  'debug': 20,\n  'info': 30,\n  'warn': 40,\n  'error': 50,\n  'fatal': 60\n}\n\nutil.inherits(Logger, Readable)\n\nfunction Logger(options, extra) {\n  if (!(this instanceof Logger)) {\n    return new Logger(options, extra)\n  }\n\n  Readable.call(this)\n  var passedInLevel = this.coerce(options.level)\n  this.options = {\n    _level: passedInLevel,\n    enabled: options.enabled === undefined ? true : options.enabled\n  }\n  this.name = options.name\n  this.hostname = options.hostname || os.hostname()\n  this.extra = extra || {}\n  this.buffer = ''\n  this.reading = false\n  if (options.stream) {\n    this.pipe(options.stream)\n  }\n}\n\nvar loggingFunctions = {}\n\nObject.keys(LEVELS).forEach(function buildLevel(_level) {\n  function log(extra) {\n    var level = Logger.prototype.coerce(LEVELS[_level])\n    if (!this.options.enabled) return false\n    if (level < this.options._level) return false\n\n    var has_extra = typeof extra === 'object'\n    var args = Array.prototype.slice.call(arguments, has_extra ? 1 : 0)\n    return this.write(level, args, has_extra ? extra : null)\n  }\n\n  loggingFunctions[_level] = function checkLevel() {\n    log.apply(this, arguments)\n  }\n\n  var seenMessages = {}\n  loggingFunctions[_level + 'Once'] = function logOnce(key) {\n    if (typeof key !== 'string') {\n      this.debug('Attempted to key on a non-string in ' + _level + 'Once: ' + key)\n      return\n    }\n\n    var level = Logger.prototype.coerce(LEVELS[_level])\n    if (!this.options.enabled) return false\n    if (level < this.options._level) return false\n\n    if (seenMessages[key] !== true) {\n      var args = Array.prototype.slice.call(arguments, 1)\n      var writeSuccessful = log.apply(this, args)\n\n      if (writeSuccessful) {\n        seenMessages[key] = true\n      }\n    }\n  }\n\n  var seenPerInterval = {}\n  loggingFunctions[_level + 'OncePer'] = function logOncePer(key, interval) {\n    if (typeof key !== 'string') {\n      this.debug('Attempted to key on a non-string in ' + _level + 'Once: ' + key)\n      return\n    }\n\n    var level = Logger.prototype.coerce(LEVELS[_level])\n    if (!this.options.enabled) return false\n    if (level < this.options._level) return false\n\n    if (seenPerInterval[key] !== true) {\n      var args = Array.prototype.slice.call(arguments, 2)\n      var writeSuccessful = log.apply(this, args)\n\n      if (writeSuccessful) {\n        seenPerInterval[key] = true\n\n        var clearSeen = setTimeout(function clearKey() {\n          delete seenPerInterval[key]\n        }, interval)\n\n        if (clearSeen.unref !== undefined) {\n          clearSeen.unref()\n        }\n      }\n    }\n  }\n})\n\nutil._extend(Logger.prototype, loggingFunctions)\n\nLogger.prototype.coerce = function coerce(value) {\n  if (!isNaN(parseInt(value, 10)) && isFinite(value)) {\n    // value is numeric\n    if (value < 10) value = 10\n    if (value > 60) value = 60\n\n    return value\n  }\n  return LEVELS[value] || 50\n}\n\nLogger.prototype.child = function child(extra) {\n  var childLogger = Object.create(loggingFunctions)\n\n  childLogger.extra = util._extend({}, this.extra)\n  util._extend(childLogger.extra, extra)\n\n  var parent = this\n  childLogger.options = parent.options\n\n  childLogger.write = function write(level, args, extra) {\n    extra = getPropertiesToLog(extra)\n    var selfExtra = util._extend({}, this.extra)\n\n    extra = util._extend(selfExtra, extra)\n    return parent.write(level, args, extra)\n  }\n\n  childLogger.setEnabled = Logger.prototype.setEnabled\n  childLogger.child = Logger.prototype.child\n\n  return childLogger\n}\n\nLogger.prototype.level = function level(lvl) {\n  this.options._level = this.coerce(lvl)\n}\n\nLogger.prototype.setEnabled = function setEnabled(enabled) {\n  if (typeof enabled === 'boolean') {\n    this.options.enabled = enabled\n  }\n}\n\nLogger.prototype._read = function _read() {\n  if (this.buffer.length !== 0) {\n    this.reading = this.push(this.buffer)\n    this.buffer = ''\n  } else {\n    this.reading = true\n  }\n}\n\n/**\n * For performance reasons we do not support %j because we will have\n * already converted the objects to strings.\n * Returns a boolean representing the status of the write\n * (success/failure)\n */\nLogger.prototype.write = function write(level, args, extra) {\n  for (var i = 0, l = args.length; i < l; ++i) {\n    if (typeof args[i] === 'function') {\n      args[i] = args[i].valueOf()\n    } else if (typeof args[i] === 'object') {\n      args[i] = stringifySync(args[i])\n    }\n  }\n\n  var entry = new Entry(this, level, util.format.apply(util, args))\n\n  util._extend(entry, this.extra)\n  util._extend(entry, getPropertiesToLog(extra))\n\n  if (this.reading) {\n    this.reading = this.push(stringifySync(entry) + '\\n')\n  } else {\n    this.buffer += stringifySync(entry) + '\\n'\n  }\n  return true\n}\n\nfunction Entry(logger, level, msg) {\n  this.v = 0\n  this.level = level\n  this.name = logger.name\n  this.hostname = logger.hostname\n  this.pid = process.pid\n  this.time = new Date().toISOString()\n  this.msg = msg\n}\n\nfunction getPropertiesToLog(extra) {\n  var obj = util._extend({}, extra)\n  // Error properties (message, stack) are not enumerable, so getting them directly\n  if (extra instanceof Error) {\n    var names = Object.getOwnPropertyNames(extra)\n    if (names) {\n      for (var i = 0; i < names.length; i++) {\n        obj[names[i]] = extra[names[i]]\n      }\n    }\n  }\n  return obj\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/util/safe-json.js":"'use strict'\n\nvar stringifySafe = require('json-stringify-safe')\n\nmodule.exports = {\n  parse: function parseAsync(str, cb) {\n    try {\n      cb(null, JSON.parse(str))\n    } catch (err) {\n      cb(err, null)\n    }\n  },\n\n  stringify: function stringifyAsync(obj, cb) {\n    try {\n      cb(null, stringifySafe(obj))\n    } catch (err) {\n      cb(err, '[UNPARSABLE OBJECT]')\n    }\n  },\n\n  stringifySync: function stringifySync(obj, returnVal) {\n    try {\n      return stringifySafe(obj)\n    } catch (err) {\n      return returnVal || '[UNPARSABLE OBJECT]'\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/node_modules/json-stringify-safe/stringify.js":"exports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/node_modules/readable-stream/readable.js":"exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = require('stream');\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\nif (!process.browser && process.env.READABLE_STREAM === 'disable') {\n  module.exports = require('stream');\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/node_modules/readable-stream/lib/_stream_readable.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\n\n/*<replacement>*/\nif (!EE.listenerCount) EE.listenerCount = function(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\nvar Stream = require('stream');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar StringDecoder;\n\n\n/*<replacement>*/\nvar debug = require('util');\nif (debug && debug.debuglog) {\n  debug = debug.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (util.isNullOrUndefined(chunk)) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = indexOf(state.pipes, dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    if (!state.reading) {\n      debug('resume read 0');\n      this.read(0);\n    }\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  forEach(events, function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf (xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/node_modules/readable-stream/lib/_stream_writable.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  var Duplex = require('./_stream_duplex');\n\n  options = options || {};\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = options.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  var Duplex = require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/node_modules/readable-stream/lib/_stream_duplex.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n/*</replacement>*/\n\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nforEach(objectKeys(Writable.prototype), function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n\nfunction forEach (xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/node_modules/readable-stream/lib/_stream_transform.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(options, stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(options, this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/node_modules/readable-stream/lib/_stream_passthrough.js":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/config.js":"'use strict'\n\nvar util = require('util')\nvar path = require('path')\nvar fs = require('fs')\nvar EventEmitter = require('events').EventEmitter\nvar NAMES = require('./metrics/names.js')\nvar feature_flag = require('./feature_flags.js')\nvar flatten = require('./util/flatten')\nvar hashes = require('./util/hashes')\nvar exists = fs.existsSync || path.existsSync\nvar safeJSON = require('./util/safe-json')\nvar stringifySync = safeJSON.stringifySync\nvar parse = safeJSON.parse\nvar os = require('os')\nvar logger\n\n/**\n * CONSTANTS -- we gotta lotta 'em\n */\nvar DEFAULT_CONFIG_PATH = path.join(__dirname, 'config.default.js')\nvar DEFAULT_CONFIG = require(DEFAULT_CONFIG_PATH).config\nvar DEFAULT_FILENAME = 'newrelic.js'\nvar AZURE_APP_NAME = 'APP_POOL_ID'\nvar CONFIG_FILE_LOCATIONS = [\n  process.env.NEW_RELIC_HOME,\n  process.cwd(),\n  process.env.HOME,\n  path.join(__dirname, '../../..') // above node_modules\n]\n\n// the REPL has no main module\nif (process.mainModule && process.mainModule.filename) {\n  CONFIG_FILE_LOCATIONS.splice(2, 0, path.dirname(process.mainModule.filename))\n}\n\n/*\n * ENV_MAPPING, LIST_VARS, and BOOLEAN_VARS could probably be unified and\n * objectified, but this is simple and works.\n */\nvar ENV_MAPPING = {\n  newrelic_home: \"NEW_RELIC_HOME\",\n  app_name: \"NEW_RELIC_APP_NAME\",\n  license_key: \"NEW_RELIC_LICENSE_KEY\",\n  ssl: \"NEW_RELIC_USE_SSL\",\n  host: \"NEW_RELIC_HOST\",\n  port: \"NEW_RELIC_PORT\",\n  proxy: \"NEW_RELIC_PROXY_URL\",\n  proxy_host: \"NEW_RELIC_PROXY_HOST\",\n  proxy_port: \"NEW_RELIC_PROXY_PORT\",\n  proxy_user: \"NEW_RELIC_PROXY_USER\",\n  proxy_pass: \"NEW_RELIC_PROXY_PASS\",\n  ignore_server_configuration: \"NEW_RELIC_IGNORE_SERVER_CONFIGURATION\",\n  agent_enabled: \"NEW_RELIC_ENABLED\",\n  apdex_t: \"NEW_RELIC_APDEX\",\n  capture_params: \"NEW_RELIC_CAPTURE_PARAMS\",\n  ignored_params: \"NEW_RELIC_IGNORED_PARAMS\",\n  logging: {\n    level: \"NEW_RELIC_LOG_LEVEL\",\n    filepath: \"NEW_RELIC_LOG\",\n    enabled: \"NEW_RELIC_LOG_ENABLED\"\n  },\n  audit_log: {\n    enabled: \"NEW_RELIC_AUDIT_LOG_ENABLED\",\n    endpoints: \"NEW_RELIC_AUDIT_LOG_ENDPOINTS\"\n  },\n  error_collector: {\n    enabled: \"NEW_RELIC_ERROR_COLLECTOR_ENABLED\",\n    ignore_status_codes: \"NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES\"\n  },\n  transaction_tracer: {\n    enabled: \"NEW_RELIC_TRACER_ENABLED\",\n    transaction_threshold: \"NEW_RELIC_TRACER_THRESHOLD\",\n    top_n: \"NEW_RELIC_TRACER_TOP_N\",\n    record_sql: \"NEW_RELIC_RECORD_SQL\",\n    explain_threshold: \"NEW_RELIC_EXPLAIN_THRESHOLD\"\n  },\n  utilization: {\n    detect_aws: \"NEW_RELIC_UTILIZATION_DETECT_AWS\",\n    detect_docker: \"NEW_RELIC_UTILIZATION_DETECT_DOCKER\",\n    logical_processors: \"NEW_RELIC_UTILIZATION_LOGICAL_PROCESSORS\",\n    total_ram_mib: \"NEW_RELIC_UTILIZATION_TOTAL_RAM_MIB\",\n    billing_hostname: \"NEW_RELIC_UTILIZATION_BILLING_HOSTNAME\"\n  },\n  debug: {\n    internal_metrics: \"NEW_RELIC_DEBUG_METRICS\",\n    tracer_tracing: \"NEW_RELIC_DEBUG_TRACER\"\n  },\n  rules: {\n    name: \"NEW_RELIC_NAMING_RULES\",\n    ignore: \"NEW_RELIC_IGNORING_RULES\"\n  },\n  enforce_backstop: \"NEW_RELIC_ENFORCE_BACKSTOP\",\n  browser_monitoring: {\n    enable: \"NEW_RELIC_BROWSER_MONITOR_ENABLE\",\n    debug: \"NEW_RELIC_BROWSER_MONITOR_DEBUG\"\n  },\n  high_security: \"NEW_RELIC_HIGH_SECURITY\",\n  labels: \"NEW_RELIC_LABELS\",\n  slow_sql: {\n    enabled: \"NEW_RELIC_SLOW_SQL_ENABLED\",\n    max_samples: \"NEW_RELIC_MAX_SQL_SAMPLES\"\n  },\n  process_host: {\n    display_name: \"NEW_RELIC_PROCESS_HOST_DISPLAY_NAME\",\n    ipv_preference: \"NEW_RELIC_IPV_PREFERENCE\"\n  },\n  datastore_tracer: {\n    instance_reporting: {\n      enabled: \"NEW_RELIC_DATASTORE_INSTANCE_REPORTING_ENABLED\"\n    },\n    database_name_reporting:{\n      enabled: \"NEW_RELIC_DATASTORE_DATABASE_NAME_REPORTING_ENABLED\"\n    }\n  }\n}\n\n// values in list variables are comma-delimited lists\nvar LIST_VARS = [\n  \"NEW_RELIC_APP_NAME\",\n  \"NEW_RELIC_IGNORED_PARAMS\",\n  \"NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES\",\n  \"NEW_RELIC_IGNORING_RULES\",\n  \"NEW_RELIC_AUDIT_LOG_ENDPOINTS\"\n]\n\n// values in object lists are comma-delimited object literals\nvar OBJECT_LIST_VARS = [\n  \"NEW_RELIC_NAMING_RULES\"\n]\n\nvar HAS_ARBITRARY_KEYS = [\n  'labels'\n]\n\n/*\n * Values in boolean variables. Is pretty tolerant about values, but\n * don't get fancy and just use 'true' and 'false', everybody.\n */\nvar BOOLEAN_VARS = [\n  \"NEW_RELIC_IGNORE_SERVER_CONFIGURATION\",\n  \"NEW_RELIC_ENABLED\",\n  \"NEW_RELIC_CAPTURE_PARAMS\",\n  \"NEW_RELIC_ERROR_COLLECTOR_ENABLED\",\n  \"NEW_RELIC_TRACER_ENABLED\",\n  \"NEW_RELIC_DEBUG_METRICS\",\n  \"NEW_RELIC_DEBUG_TRACER\",\n  \"NEW_RELIC_ENFORCE_BACKSTOP\",\n  \"NEW_RELIC_USE_SSL\",\n  \"NEW_RELIC_BROWSER_MONITOR_ENABLE\",\n  \"NEW_RELIC_BROWSER_MONITOR_DEBUG\",\n  \"NEW_RELIC_HIGH_SECURITY\",\n  \"NEW_RELIC_SLOW_SQL_ENABLED\",\n  \"NEW_RELIC_LOG_ENABLED\",\n  \"NEW_RELIC_AUDIT_LOG_ENABLED\",\n  \"NEW_RELIC_DATASTORE_DATABASE_NAME_REPORTING_ENABLED\",\n  \"NEW_RELIC_DATASTORE_INSTANCE_REPORTING_ENABLED\"\n]\n\nvar FLOAT_VARS = [\n  'NEW_RELIC_APDEX'\n]\n\nvar INT_VARS = [\n  'NEW_RELIC_EXPLAIN_THRESHOLD',\n  'NEW_RELIC_MAX_SQL_SAMPLES'\n]\n\n// Config keys that can't be set by the server if high_security === true\nvar HIGH_SECURITY_SETTINGS = {\n  ssl: true,\n  capture_params: false,\n  transaction_tracer: {\n    record_sql: 'off'\n  },\n  slow_sql: {\n    enabled: false\n  }\n}\n\nvar HIGH_SECURITY_KEYS = Object.keys(flatten({}, '', HIGH_SECURITY_SETTINGS))\n\n// blank out these config values before sending to the collector\nvar REDACT_BEFORE_SEND = ['proxy_pass', 'proxy_user', 'proxy']\n\n// process.domain needs to be stripped befeore sending\nvar REMOVE_BEFORE_SEND = ['domain']\n\nvar _configInstance = null\n\nfunction isTruthular(setting) {\n  if (setting === undefined || setting === null) return false\n\n  var normalized = setting.toString().toLowerCase()\n  switch (normalized) {\n    case 'false':\n    case 'f':\n    case 'no':\n    case 'n':\n    case 'disabled':\n    case '0':\n      return false\n\n    default:\n      return true\n  }\n}\n\nfunction fromObjectList(setting) {\n  try {\n    return JSON.parse('[' + setting + ']')\n  } catch (error) {\n    logger.error(\"New Relic configurator could not deserialize object list:\")\n    logger.error(error.stack)\n  }\n}\n\nfunction _findConfigFile() {\n  var candidate\n  var filepath\n\n\n  for (var i = 0; i < CONFIG_FILE_LOCATIONS.length; i++) {\n    candidate = CONFIG_FILE_LOCATIONS[i]\n    if (!candidate) continue\n\n    filepath = path.join(path.resolve(candidate), DEFAULT_FILENAME)\n    if (!exists(filepath)) continue\n\n    return fs.realpathSync(filepath)\n  }\n}\n\nfunction Config(config) {\n  EventEmitter.call(this)\n\n  // 1. start by cloning the defaults\n  try {\n    var basis = JSON.parse(stringifySync(DEFAULT_CONFIG))\n    Object.keys(basis).forEach(function cb_forEach(key) {\n      this[key] = basis[key]\n    }, this)\n  } catch (err) {\n    logger.warn('Unable to clone the default config, %s: %s', DEFAULT_CONFIG_PATH, err)\n  }\n\n  if (config &&\n      (process.env[ENV_MAPPING.ssl] === 'false' || config.ssl === false) &&\n      process.env[ENV_MAPPING.port] === undefined && config.port === undefined ) {\n    config.port = 80\n  }\n\n  // 2. initialize undocumented, internal-only default values\n\n  // feature flags are mostly private settings for gating unreleased features\n  // flags are set in the feature_flags.js file\n  this.feature_flag = feature_flag.prerelease\n\n  // set by environment\n  this.newrelic_home = null\n  // set by configuration file loader\n  this.config_file_path = null\n  // set by collector on handshake\n  this.run_id = null\n  this.application_id = null\n  this.web_transactions_apdex = {}\n  this.cross_process_id = null\n  this.encoding_key = null\n  this.obfuscatedId = null\n  this.trusted_account_ids = null\n\n  // how frequently harvester runs\n  this.data_report_period = 60\n\n  // this value is arbitrary\n  this.max_trace_segments = 900\n\n  // feature level of this account\n  this.product_level = 0\n  // product-level related\n  this.collect_traces = true\n  this.collect_errors = true\n\n  // override options for utilization stats\n  this.utilization.logical_processors = null\n  this.utilization.total_ram_mib = null\n  this.utilization.billing_hostname = null\n\n  this.browser_monitoring.loader = 'rum'\n  this.browser_monitoring.loader_version = ''\n\n  // Settings to play nice with DLPs (see NODE-1044).\n  this.compressed_content_encoding = \"deflate\"  // Deflate or gzip\n  this.simple_compression = false               // Disables subcomponent compression\n  this.put_for_data_send = false                // Changes http verb for harvest\n\n\n  // 3. override defaults with values from the loaded / passed configuration\n  this._fromPassed(config)\n\n  // 3.5. special values (only Azure environment APP_POOL_ID for now)\n  this._fromSpecial()\n\n  // 4. override config with environment variables\n  this._fromEnvironment()\n\n  // 5. clean up anything that requires postprocessing\n  this._canonicalize()\n\n  // 6. put the version in the config\n  this.version = require('../package.json').version\n\n  // 7. apply high security overrides\n  if (this.high_security === true) {\n    this._applyHighSecurity()\n  }\n}\nutil.inherits(Config, EventEmitter)\n\n/**\n * Because this module and logger depend on each other, the logger needs\n * a way to inject the actual logger instance once it's constructed.\n * It's kind of a Rube Goldberg device, but it works.\n *\n * @param {Logger} bootstrapped The actual, configured logger.\n */\nConfig.prototype.setLogger = function setLogger(bootstrapped) {\n  logger = bootstrapped\n}\n\n/**\n * Accept any configuration passed back from the server. Will log all\n * recognized, unsupported, and unknown parameters. Some may not be set,\n * depending on the setting of ignore_server_configuration.\n *\n * @param {object} json The config blob sent by New Relic.\n */\nConfig.prototype.onConnect = function onConnect(json, recursion) {\n  json = json || {}\n  if (this.high_security === true && recursion !== true && json.high_security !== true) {\n    this.agent_enabled = false\n    this.emit('agent_enabled', false)\n    return\n  }\n  if (Object.keys(json).length === 0) return\n\n  Object.keys(json).forEach(function cb_forEach(key) {\n    this._fromServer(json, key)\n  }, this)\n\n  this.emit('change', this)\n}\n\n/**\n * The guts of the logic about how to deal with server-side configuration.\n *\n * @param {object} params A configuration dictionary.\n * @param {string} key    The particular configuration parameter to set.\n */\nConfig.prototype._fromServer = function _fromServer(params, key) {\n  switch (key) {\n    // handled by the connection\n    case 'messages':\n      break\n\n    // *sigh* Xzibit, etc.\n    case 'agent_config':\n      this.onConnect(params[key], true)\n      break\n\n    // if it's undefined or null, so be it\n    case 'agent_run_id':\n      this.run_id = params.agent_run_id\n      break\n\n    // handled by config.onConnect\n    case 'high_security':\n      break\n\n    // always accept these settings\n    case 'cross_process_id':\n    case 'encoding_key':\n      this._alwaysUpdateIfChanged(params, key)\n      if (this.cross_process_id && this.encoding_key) {\n        this.obfuscatedId = hashes.obfuscateNameUsingKey(this.cross_process_id,\n                                                         this.encoding_key)\n      }\n      break\n\n    // always accept these settings\n    case 'collect_traces':\n    case 'collect_errors':\n    case 'product_level':\n    case 'application_id':\n    case 'trusted_account_ids':\n      this._alwaysUpdateIfChanged(params, key)\n      break\n\n    case 'collect_error_events':\n      if (params.collect_error_events === false) {\n        this._updateNestedIfChanged(\n          params,\n          this.error_collector,\n          key,\n          'capture_events'\n        )\n      }\n      break\n\n    // also accept these settings\n    case 'url_rules':\n    case 'metric_name_rules':\n    case 'transaction_name_rules':\n    case 'transaction_segment_terms':\n      this._emitIfSet(params, key)\n      break\n\n    // setting these can be disabled by ignore_server_configuration\n    case 'ssl':\n    case 'apdex_t':\n    case 'web_transactions_apdex':\n    case 'data_report_period':\n    case 'ignored_params':\n      this._updateIfChanged(params, key)\n      break\n    case 'transaction_tracer.enabled':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_tracer,\n        'transaction_tracer.enabled',\n        'enabled'\n      )\n      break\n    case 'transaction_tracer.transaction_threshold':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_tracer,\n        'transaction_tracer.transaction_threshold',\n        'transaction_threshold'\n      )\n      break\n    case 'error_collector.enabled':\n      this._updateNestedIfChanged(\n        params,\n        this.error_collector,\n        'error_collector.enabled',\n        'enabled'\n      )\n      break\n    case 'error_collector.ignore_status_codes':\n      this._updateNestedIfChanged(\n        params,\n        this.error_collector,\n        'error_collector.ignore_status_codes',\n        'ignore_status_codes'\n      )\n      this._canonicalize()\n      break\n\n    case 'error_collector.capture_events':\n      this._updateNestedIfChanged(\n        params,\n        this.error_collector,\n        'error_collector.capture_events',\n        'capture_events'\n      )\n      break\n\n    case 'error_collector.max_event_samples_stored':\n      this._updateNestedIfChanged(\n        params,\n        this.error_collector,\n        'error_collector.max_event_samples_stored',\n        'max_event_samples_stored'\n      )\n      break\n\n    case 'collect_analytics_events':\n      // never enable from server-side\n      // but we allow the server to disable\n      if (params.collect_analytics_events === false)\n        this.transaction_events.enabled = false\n      break\n\n    case 'collect_custom_events':\n      // never enable from server-side\n      // but we allow the server to disable\n      if (params.collect_custom_events === false)\n        this.custom_insights_events.enabled = false\n      break\n\n    case 'transaction_events.max_samples_stored':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_events,\n        key,\n        'max_samples_stored'\n      )\n      break\n\n    case 'transaction_events.max_samples_per_minute':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_events,\n        key,\n        'max_samples_per_minute'\n      )\n      break\n\n    case 'transaction_events.enabled':\n      this._updateNestedIfChanged(\n        params,\n        this.transaction_events,\n        key,\n        'enabled'\n      )\n      break\n\n    // these are used by browser_monitoring\n    // and the api.getRUMHeader() method\n    case 'js_agent_file':\n    case 'js_agent_loader_file':\n    case 'beacon':\n    case 'error_beacon':\n    case 'browser_key':\n    case 'js_agent_loader':\n      this._updateNestedIfChangedRaw(\n        params,\n        this.browser_monitoring,\n        key,\n        key\n      )\n      break\n\n    case 'browser_monitoring.loader':\n      this._updateNestedIfChangedRaw(\n        params,\n        this.browser_monitoring,\n        key,\n        'loader'\n      )\n      break\n\n    // After 2015-02, the collector no longer supports the capture_params setting.\n    case 'capture_params':\n      break\n    // these settings aren't supported by the agent (yet)\n    case 'sampling_rate':\n    case 'episodes_file':\n    case 'episodes_url':\n    case 'cross_application_tracing':\n    case 'transaction_tracer.record_sql':\n    case 'slow_sql.enabled':\n    case 'rum.load_episodes_file':\n      this.logUnsupported(params, key)\n      break\n\n    default:\n      this.logUnknown(params, key)\n  }\n}\n\n/**\n * Change a value sent by the collector if and only if it's different from the\n * value we already have. Emit an event with the key name and the new value,\n * and log that the value has changed.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._alwaysUpdateIfChanged = function _alwaysUpdateIfChanged(json, key) {\n  var value = json[key]\n  if (value !== null && value !== undefined && this[key] !== value) {\n    if (Array.isArray(value) && Array.isArray(this[key])) {\n      value.forEach(function cb_forEach(element) {\n        if (this[key].indexOf(element) === -1) this[key].push(element)\n      }, this)\n    } else {\n      this[key] = value\n    }\n    this.emit(key, value)\n    logger.debug(\"Configuration of %s was changed to %s by New Relic.\", key, value)\n  }\n}\n\n/**\n * Change a value sent by the collector if and only if it's different from the\n * value we already have. Emit an event with the key name and the new value,\n * and log that the value has changed. Parameter will be ignored if\n * ignore_server_configuration is set.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._updateIfChanged = function _updateIfChanged(json, key) {\n  this._updateNestedIfChanged(json, this, key, key)\n}\n\n/**\n * Some parameter values are nested, need a simple way to change them as well.\n * Will merge local and remote if and only if both are arrays. Parameter will\n * be ignored if ignore_server_configuration is set.\n *\n * @param {object} remote    JSON sent from New Relic.\n * @param {object} local     A portion of this configuration object.\n * @param {string} remoteKey The name sent by New Relic.\n * @param {string} localKey  The local name.\n */\nConfig.prototype._updateNestedIfChanged = _updateNestedIfChanged\n\nfunction _updateNestedIfChanged(remote, local, remoteKey, localKey) {\n  if (this.ignore_server_configuration) return this.logDisabled(remote, remoteKey)\n  // if high-sec mode is enabled, we do not accept server changes to high-sec\n  if (this.high_security && HIGH_SECURITY_KEYS.indexOf(localKey) !== -1) {\n    return this.logDisabled(remote, remoteKey)\n  }\n  return this._updateNestedIfChangedRaw(remote, local, remoteKey, localKey)\n}\n\nConfig.prototype._updateNestedIfChangedRaw = function _updateNestedIfChangedRaw(\n    remote, local, remoteKey, localKey) {\n  var value = remote[remoteKey]\n  if (value !== null && value !== undefined && local[localKey] !== value) {\n    if (Array.isArray(value) && Array.isArray(local[localKey])) {\n      value.forEach(function cb_forEach(element) {\n        if (local[localKey].indexOf(element) === -1) local[localKey].push(element)\n      })\n    } else {\n      local[localKey] = value\n    }\n    this.emit(remoteKey, value)\n    logger.debug(\"Configuration of %s was changed to %s by New Relic.\", remoteKey, value)\n  }\n}\n\n/**\n * Some parameter values are just to be passed on.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value we're looking to set.\n */\nConfig.prototype._emitIfSet = function _emitIfSet(json, key) {\n  var value = json[key]\n  if (value !== null && value !== undefined) this.emit(key, value)\n}\n\n/**\n * The agent would normally do something with this parameter, but server-side\n * configuration is disabled via ignore_server_configuration.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent won't set.\n */\nConfig.prototype.logDisabled = function logDisabled(json, key) {\n  var value = json[key]\n  if (value !== null && value !== undefined) {\n    logger.debug(\n      \"Server-side configuration of %s is currently disabled by local configuration. \" +\n      \"(Server sent value of %s.)\",\n      key,\n      value\n    )\n  }\n}\n\n/**\n * Help support out by putting in the logs the fact that we don't currently\n * support the provided configuration key, and including the sent value.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent doesn't set.\n */\nConfig.prototype.logUnsupported = function logUnsupported(json, key) {\n  var flavor\n  if (this.ignore_server_configuration) {\n    flavor = \"ignored\"\n  } else {\n    flavor = \"not supported by the Node.js agent\"\n  }\n\n  var value = json[key]\n  if (value !== null && value !== undefined) {\n    logger.debug(\n      \"Server-side configuration of %s is currently %s. (Server sent value of %s.)\",\n      key,\n      flavor,\n      value\n    )\n    this.emit(key, value)\n  }\n}\n\n/**\n * The agent knows nothing about this parameter.\n *\n * @param {object} json Config blob sent by collector.\n * @param {string} key  Value the agent knows nothing about.\n */\nConfig.prototype.logUnknown = function logUnknown(json, key) {\n  var value = json[key]\n  logger.debug(\n    \"New Relic sent unknown configuration parameter %s with value %s.\",\n    key,\n    value\n  )\n}\n\n/**\n * Gets the user set host display name. If not provided, it returns the default value.\n *\n * This function is written is this strange way becauase of the use of caching variables.\n * I wanted to cache the DisplayHost, but if I attached the variable to the config object,\n * it sends the extra variable to New Relic, which is not desired.\n *\n * @return {string} display host name\n */\nConfig.prototype.getDisplayHost = getDisplayHost\n\nConfig.prototype.clearDisplayHostCache = function clearDisplayHostCache() {\n  this.getDisplayHost = getDisplayHost\n}\n\nfunction getDisplayHost() {\n  var _displayHost\n  this.getDisplayHost = function getCachedDisplayHost() {\n    return _displayHost\n  }\n  if (this.process_host.display_name === '') {\n    _displayHost = this.getHostnameSafe()\n    return _displayHost\n  }\n  var stringBuffer = new Buffer(this.process_host.display_name, 'utf8')\n  var numBytes = stringBuffer.length\n\n  if (numBytes > 255) {\n    logger.warn('Custom host display name must be less than 255 bytes')\n    _displayHost = this.getHostnameSafe()\n    return _displayHost\n  }\n\n  _displayHost = this.process_host.display_name\n  return _displayHost\n}\n\n/**\n * Gets the system's host name. If that fails, it just returns ipv4/6 based on the user's\n * process_host.ipv_preferenece setting.\n *\n * This function is written is this strange way becauase of the use of caching variables.\n * I wanted to cache the Hostname, but if I attached the variable to the config object,\n * it sends the extra variable to New Relic, which is not desired.\n *\n * @return {string} host name\n */\nConfig.prototype.getHostnameSafe = getHostnameSafe\n\nConfig.prototype.clearHostnameCache = function clearHostnameCache() {\n  this.getHostnameSafe = getHostnameSafe\n}\n\nConfig.prototype.getIPAddresses = function getIPAddresses() {\n  var addresses = {}\n  var interfaces = os.networkInterfaces()\n\n  for (var interfaceKey in interfaces) {\n    if (interfaceKey.match(/^lo/)) continue\n\n    var interfaceDescriptions = interfaces[interfaceKey]\n    for (var i = 0; i < interfaceDescriptions.length; i++) {\n      var description = interfaceDescriptions[i]\n      var family = description.family.toLowerCase()\n      addresses[family] = description.address\n    }\n  }\n  return addresses\n}\n\nfunction getHostnameSafe() {\n  var _hostname\n  this.getHostnameSafe = function getCachedHostname() {\n    return _hostname\n  }\n  try {\n    _hostname = os.hostname()\n    return _hostname\n  } catch (e) {\n    var addresses = this.getIPAddresses()\n\n    if (this.process_host.ipv_preference === '6' && addresses.ipv6) {\n      _hostname = addresses.ipv6\n    } else if (addresses.ipv4) {\n      logger.info('Defaulting to ipv4 address for host name')\n      _hostname = addresses.ipv4\n    } else if (addresses.ipv6) {\n      logger.info('Defaulting to ipv6 address for host name')\n      _hostname = addresses.ipv6\n    } else {\n      logger.info('No hostname, ipv4, or ipv6 address found for machine')\n      _hostname = 'UNKNOWN_BOX'\n    }\n\n    return _hostname\n  }\n}\n\n/**\n * Ensure that the apps names are always returned as a list.\n */\nConfig.prototype.applications = function applications() {\n  var apps = this.app_name\n\n  if (Array.isArray(apps) && apps.length > 0) {\n    return apps\n  }\n\n  if (apps && typeof apps === 'string') {\n    return [apps]\n  }\n\n  return []\n}\n\n/**\n * Safely overwrite defaults with values passed to constructor.\n *\n * @param object external The configuration being loaded.\n * @param object internal Whichever chunk of the config being overridden.\n */\nConfig.prototype._fromPassed = function _fromPassed(external, internal, arbitrary) {\n  if (!external) return\n  if (!internal) internal = this\n\n  Object.keys(external).forEach(function cb_forEach(key) {\n    // if it's not in the defaults, it doesn't exist\n    if (!arbitrary && internal[key] === undefined) return\n\n    try {\n      var node = external[key]\n    } catch (err) {\n      logger.warn('Error thrown on access of user config for key: %s', key)\n      return\n    }\n\n    if (Array.isArray(node)) {\n      internal[key] = node\n    } else if (typeof node === 'object') {\n      // is top level and can have arbitrary keys\n      if (internal === this && HAS_ARBITRARY_KEYS.indexOf(key) !== -1) {\n        this._fromPassed(node, internal[key], true)\n      } else {\n        this._fromPassed(node, internal[key], false)\n      }\n    } else {\n      internal[key] = node\n    }\n  }, this)\n}\n\n/**\n * Some values should be picked up only if they're not otherwise set, like\n * the Windows / Azure application name. Don't set it if there's already\n * a non-empty value set via the configuration file, and allow these\n * values to be overwritten by environment variables. Just saves a step for\n * PaaS users who don't want to have multiple settings for a single piece\n * of configuration.\n */\nConfig.prototype._fromSpecial = function _fromSpecial() {\n  var name = this.app_name\n  if (name === null || name === undefined || name === '' ||\n      (Array.isArray(name) && name.length === 0)) {\n    var azureName = process.env[AZURE_APP_NAME]\n    if (azureName) this.app_name = azureName.split(',')\n  }\n}\n\n/**\n * Recursively visit the nodes of the constant containing the mapping between\n * environment variable names, overriding any configuration values that are\n * found in the environment. Operates purely via side effects.\n *\n * @param object metadata The current level of the mapping object. Should never\n *                        need to set this yourself.\n * @param object data     The current level of the configuration object. Should\n *                        never need to set this yourself.\n */\nConfig.prototype._fromEnvironment = function _fromEnvironment(metadata, data) {\n  if (!metadata) metadata = ENV_MAPPING\n  if (!data) data = this\n\n  Object.keys(metadata).forEach(function cb_forEach(value) {\n    // if it's not in the config, it doesn't exist\n    if (data[value] === undefined) return\n\n    var node = metadata[value]\n    if (typeof node === 'string') {\n      var setting = process.env[node]\n      if (setting) {\n        if (LIST_VARS.indexOf(node) > -1) {\n          data[value] = setting.split(',').map(function cb_map(k) {\n            return k.trim()\n          })\n        } else if (OBJECT_LIST_VARS.indexOf(node) > -1) {\n          data[value] = fromObjectList(setting)\n        } else if (BOOLEAN_VARS.indexOf(node) > -1) {\n          data[value] = isTruthular(setting)\n        } else if (FLOAT_VARS.indexOf(node) > -1) {\n          data[value] = parseFloat(setting, 10)\n        } else if (INT_VARS.indexOf(node) > -1) {\n          data[value] = parseInt(setting, 10)\n        } else {\n          data[value] = setting\n        }\n      }\n    } else {\n      // don't crash if the mapping has config keys the current config doesn't.\n      if (!data[value]) data[value] = {}\n      this._fromEnvironment(node, data[value])\n    }\n  }, this)\n}\n\n/**\n * Depending on how the status codes are set, they could be strings, which\n * makes strict equality testing / indexOf fail. To keep things cheap, parse\n * them once, after configuration has finished loading. Other one-off shims\n * based on special properties of configuration values should go here as well.\n */\nConfig.prototype._canonicalize = function _canonicalize() {\n  var codes = this.error_collector && this.error_collector.ignore_status_codes\n  if (codes) {\n    this.error_collector.ignore_status_codes = codes.map(function cb_map(code) {\n      return parseInt(code, 10)\n    })\n  }\n\n  var logAliases = {\n    'verbose': 'trace',\n    'debugging': 'debug',\n    'warning': 'warn',\n    'err': 'error'\n  }\n  var level = this.logging.level\n  this.logging.level = logAliases[level] || level\n}\n\n/**\n * This goes through the settings that high security mode needs and coerces\n * them to be correct.\n */\nConfig.prototype._applyHighSecurity = function _applyHighSecurity() {\n  var config = this\n  checkNode('', this, HIGH_SECURITY_SETTINGS)\n\n  function checkNode(base, target, settings) {\n    Object.keys(settings).forEach(checkKey.bind(null, base, target, settings))\n  }\n\n  function checkKey(base, target, settings, key) {\n    var hsValue = settings[key]\n\n\n    if (hsValue && typeof hsValue === 'object') {\n      if (typeof target[key] !== 'object') {\n        logger.warn(\n          'High Security Mode: %s should be an object, found %s',\n          key,\n          target[key]\n        )\n        target[key] = {}\n      }\n\n      return checkNode(base + key + '.', target[key], hsValue)\n    }\n\n    if (target[key] !== hsValue) {\n      logger.warn('High Security Mode: %s was set to %s, coercing to %s',\n                  key, target[key], hsValue)\n      target[key] = hsValue\n      config.emit(base + key, hsValue)\n    }\n  }\n}\n\n/**\n * The agent will use the supportability metrics object if it's\n * available.\n *\n * @param string suffix Supportability metric name.\n * @param number duration Milliseconds that the measured operation took.\n */\nConfig.prototype.measureInternal = function measureInternal(suffix, duration) {\n  if (this.debug.supportability) {\n    var internal = this.debug.supportability\n    internal.measureMilliseconds(NAMES.SUPPORTABILITY.PREFIX + suffix, null, duration)\n  }\n}\n\nConfig.prototype.validateFlags = function validateFlags() {\n  Object.keys(this.feature_flag).forEach(function cb_forEach(key) {\n    if (feature_flag.released.indexOf(key) > -1) {\n      logger.warn('Feature flag ' + key + ' has been released')\n    }\n    if (feature_flag.unreleased.indexOf(key) > -1) {\n      logger.warn('Feature flag ' + key + ' has been deprecated')\n    }\n  })\n}\n\n/**\n * Get a JSONifiable object containing all settings we want to report to the\n * collector and store in the environment_values table.\n *\n * @return Object containing simple key-value pairs of settings\n */\nConfig.prototype.publicSettings = function publicSettings() {\n  var settings = {}\n\n  for (var key in this) {\n    if (this.hasOwnProperty(key)) {\n      var item = this[key]\n\n      if (REDACT_BEFORE_SEND.indexOf(key) > -1) {\n        item = '****'\n      }\n\n      if (REMOVE_BEFORE_SEND.indexOf(key) === -1) {\n        settings[key] = item\n      }\n    }\n  }\n\n  // Agent-side setting is 'enable', but collector-side setting is\n  // 'auto_instrument'. Send both values up.\n  settings.browser_monitoring.auto_instrument = settings.browser_monitoring.enable\n\n  // Remove simple circular references\n  parse(stringifySync(settings), function cb_parse(err, settingsCopy) {\n    if (err === null) {\n      settings = flatten({}, '', settingsCopy)\n    } else {\n      logger.warn('Error while creating deep copy: %s', err)\n    }\n  })\n\n  return settings\n}\n\n/**\n * Create a configuration, either from a configuration file or the node\n * process's environment.\n *\n * For configuration via file, check these directories, in order, for a\n * file named 'newrelic.js':\n *\n *   1. The process's current working directory at startup.\n *   2. The same directory as the process's main module (i.e. the filename\n *      passed to node on the command line).\n *   3. The directory pointed to by the environment variable NEW_RELIC_HOME.\n *   4. The current process's HOME directory.\n *   5. If this module is installed as a dependency, the directory above the\n *      node_modules folder in which newrelic is installed.\n *\n * For configration via environment (useful on Joyent, Azure, Heroku, or\n * other PaaS offerings), set NEW_RELIC_NO_CONFIG_FILE to something truthy\n * and read README.md for details on what configuration variables are\n * necessary, as well as a complete enumeration of the other available\n * variables.\n *\n * @param {object} config Optional configuration to be used in place of a\n *                        config file.\n */\nfunction initialize(config) {\n  /* When the logger is required here, it bootstraps itself and then\n   * injects itself into this module's closure via setLogger on the\n   * instance of the logger it creates.\n   */\n  logger = require('./logger.js')\n\n  if (config) return new Config(config)\n\n  if (isTruthular(process.env.NEW_RELIC_NO_CONFIG_FILE)) {\n    config = new Config({})\n    if (config.newrelic_home) delete config.newrelic_home\n    return config\n  }\n\n  var filepath = _findConfigFile()\n  if (!filepath) {\n    _noConfigFile()\n    return null\n  }\n\n  try {\n    config = new Config(require(filepath).config)\n    config.config_file_path = filepath\n    logger.debug(\"Using configuration file %s.\", filepath)\n\n    config.validateFlags()\n\n    return config\n  } catch (error) {\n    logger.error(error)\n\n    throw new Error(\n      \"Unable to read configuration file \" + filepath + \". A default\\n\" +\n      \"configuration file can be copied from \" + DEFAULT_CONFIG_PATH + \"\\n\" +\n      \"and renamed to 'newrelic.js' in the directory from which you'll be starting\\n\" +\n      \"your application.\"\n    )\n  }\n}\n\nfunction _noConfigFile() {\n  var mainpath = path.resolve(path.join(process.cwd(), DEFAULT_FILENAME))\n  var altpath = path.resolve(\n    path.dirname(process.mainModule.filename),\n    DEFAULT_FILENAME\n  )\n\n  var locations\n  if (mainpath !== altpath) {\n    locations = mainpath + \" or\\n\" + altpath\n  } else {\n    locations = mainpath\n  }\n\n  /* eslint-disable no-console */\n  console.error(\n    \"Unable to find New Relic module configuration. A default\\n\" +\n    \"configuration file can be copied from \" + DEFAULT_CONFIG_PATH + \"\\n\" +\n    \"and put at \" + locations + \". If you are not using file based config\\n\" +\n    \"please set the environment variable NEW_RELIC_NO_CONFIG_FILE=true\"\n  )\n  /* eslint-enable no-console */\n}\n\n/**\n * This function honors the singleton nature of this module while allowing\n * consumers to just request an instance without having to worry if one was\n * already created.\n */\nfunction getOrCreateInstance() {\n  if (_configInstance === null) {\n    _configInstance = initialize()\n  }\n  return _configInstance\n}\n\n/**\n * Preserve the legacy initializer, but also allow consumers to manage their\n * own configuration if they choose.\n */\nConfig.initialize = initialize\nConfig.getOrCreateInstance = getOrCreateInstance\n\nmodule.exports = Config\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/metrics/names.js":"'use strict'\n\nvar NODEJS = {\n  PREFIX: 'Nodejs/'\n}\n\nvar ALL = 'all'\n\nvar ERRORS = {\n  PREFIX: 'Errors/',\n  ALL: 'Errors/' + ALL,\n  WEB: 'Errors/allWeb',\n  OTHER: 'Errors/allOther'\n}\n\nvar EVENTS = {\n  WAIT: 'Events/wait'\n}\n\nvar MEMORY = {\n  PHYSICAL: 'Memory/Physical',\n  FREE_HEAP: 'Memory/Heap/Free',\n  USED_HEAP: 'Memory/Heap/Used',\n  MAX_HEAP: 'Memory/Heap/Max',\n  USED_NONHEAP: 'Memory/NonHeap/Used'\n}\n\nvar CPU = {\n  SYSTEM_TIME: 'CPU/System Time',\n  SYSTEM_UTILIZATION: 'CPU/System/Utilization',\n  USER_TIME: 'CPU/User Time',\n  USER_UTILIZATION: 'CPU/User/Utilization'\n}\n\nvar GC = {\n  PREFIX: 'GC/',\n  PAUSE_TIME: 'GC/System/Pauses'\n}\n\nvar VIEW = {\n  PREFIX: 'View/',\n  RENDER: '/Rendering'\n}\n\nvar LOOP = {\n  PREFIX: NODEJS.PREFIX + 'EventLoop/',\n  USAGE: NODEJS.PREFIX + 'EventLoop/CPU/Usage'\n}\n\nvar DB = {\n  PREFIX: 'Datastore/',\n  STATEMENT: 'Datastore/statement',\n  OPERATION: 'Datastore/operation',\n  INSTANCE: 'Datastore/instance',\n  ALL: 'Datastore/' + ALL,\n  WEB: 'allWeb',\n  OTHER: 'allOther'\n}\n\nvar EXTERNAL = {\n  PREFIX: 'External/',\n  ALL: 'External/' + ALL,\n  WEB: 'External/allWeb',\n  OTHER: 'External/allOther',\n  APP: 'ExternalApp/',\n  TRANSACTION: 'ExternalTransaction/'\n}\n\nvar FUNCTION = {\n  PREFIX: 'Function/'\n}\n\nvar MIDDLEWARE = {\n  PREFIX: NODEJS.PREFIX + 'Middleware/'\n}\n\nvar FS = {\n  PREFIX: 'Filesystem/'\n}\n\nvar MEMCACHE = {\n  PREFIX: 'Memcache',\n  OPERATION: DB.OPERATION + '/Memcache/',\n  INSTANCE: DB.INSTANCE + '/Memcache/',\n  ALL: DB.PREFIX + 'Memcache/' + ALL\n}\n\nvar MONGODB = {\n  PREFIX: 'MongoDB',\n  STATEMENT: DB.STATEMENT + '/MongoDB/',\n  OPERATION: DB.OPERATION + '/MongoDB/',\n  INSTANCE: DB.INSTANCE + '/MongoDB/'\n}\n\nvar MYSQL = {\n  PREFIX: 'MySQL',\n  STATEMENT: DB.STATEMENT + '/MySQL/',\n  OPERATION: DB.OPERATION + '/MySQL/',\n  INSTANCE: DB.INSTANCE + '/MySQL/'\n}\n\nvar REDIS = {\n  PREFIX: 'Redis',\n  OPERATION: DB.OPERATION + '/Redis/',\n  INSTANCE: DB.INSTANCE + '/Redis/',\n  ALL: DB.PREFIX + 'Redis/' + ALL\n}\n\nvar POSTGRES = {\n  PREFIX: 'Postgres',\n  STATEMENT: DB.STATEMENT + '/Postgres/',\n  OPERATION: DB.OPERATION + '/Postgres/',\n  INSTANCE: DB.INSTANCE + '/Postgres/'\n}\n\nvar CASSANDRA = {\n  PREFIX: 'Cassandra',\n  OPERATION: DB.OPERATION + '/Cassandra/',\n  STATEMENT: DB.STATEMENT + '/Cassandra/',\n  INSTANCE: DB.INSTANCE + '/Cassandra/',\n  ALL: DB.PREFIX + 'Cassandra/' + ALL\n\n}\n\nvar ORACLE = {\n  PREFIX: 'Oracle',\n  STATEMENT: DB.STATEMENT + '/Oracle/',\n  OPERATION: DB.OPERATION + '/Oracle/',\n  INSTANCE: DB.INSTANCE + '/Oracle/'\n}\n\nvar EXPRESS = {\n  PREFIX: 'Expressjs/',\n  MIDDLEWARE: MIDDLEWARE.PREFIX + 'Expressjs/',\n  ERROR_HANDLER: MIDDLEWARE.PREFIX + 'Expressjs/'\n}\n\nvar RESTIFY = {\n  PREFIX: 'Restify/'\n}\n\nvar HAPI = {\n  PREFIX: 'Hapi/'\n}\n\nvar SUPPORTABILITY = {\n  PREFIX: 'Supportability/',\n  UNINSTRUMENTED: 'Supportability/Uninstrumented',\n  EVENTS: 'Supportability/Events',\n  API: 'Supportability/API',\n  UTILIZATION: 'Supportability/utilization',\n  DEPENDENCIES: 'Supportability/InstalledDependencies'\n}\n\nvar UTILIZATION = {\n  AWS_ERROR: SUPPORTABILITY.UTILIZATION + '/aws/error',\n  DOCKER_ERROR: SUPPORTABILITY.UTILIZATION + '/docker/error'\n}\n\n\nvar CUSTOM_EVENTS = {\n  PREFIX: SUPPORTABILITY.EVENTS + '/Customer/',\n  DROPPED: SUPPORTABILITY.EVENTS + '/Customer/Dropped',\n  SEEN: SUPPORTABILITY.EVENTS + '/Customer/Seen',\n  SENT: SUPPORTABILITY.EVENTS + '/Customer/Sent',\n  TOO_LARGE: SUPPORTABILITY.EVENTS + '/Customer/TooLarge',\n  FAILED: SUPPORTABILITY.EVENTS + '/Customer/FailedToSend'\n}\n\nvar TRANSACTION_ERROR = {\n  SEEN: SUPPORTABILITY.EVENTS + '/TransactionError/Seen',\n  SENT: SUPPORTABILITY.EVENTS + '/TransactionError/Sent'\n}\n\nvar WEB = {\n  RESPONSE_TIME: 'WebTransaction',\n  TOTAL_TIME: 'WebTransactionTotalTime'\n}\n\nvar BACKGROUND = {\n  RESPONSE_TIME: 'OtherTransaction',\n  TOTAL_TIME: 'OtherTransactionTotalTime'\n}\n\nvar TRUNCATED = {\n  PREFIX: 'Truncated/'\n}\n\nmodule.exports = {\n  ACTION_DELIMITER: '/',\n  ALL: ALL,\n  APDEX: 'Apdex',\n  BACKGROUND: BACKGROUND,\n  CASSANDRA: CASSANDRA,\n  CLIENT_APPLICATION: 'ClientApplication',\n  CONTROLLER: 'Controller',\n  CPU: CPU,\n  GC: GC,\n  CUSTOM: 'Custom',\n  CUSTOM_EVENTS: CUSTOM_EVENTS,\n  DB: DB,\n  ERRORS: ERRORS,\n  EVENTS: EVENTS,\n  EXPRESS: EXPRESS,\n  EXTERNAL: EXTERNAL,\n  FS: FS,\n  FUNCTION: FUNCTION,\n  HAPI: HAPI,\n  HTTP: 'HttpDispatcher',\n  LOOP: LOOP,\n  MEMCACHE: MEMCACHE,\n  MEMORY: MEMORY,\n  MONGODB: MONGODB,\n  MYSQL: MYSQL,\n  NORMALIZED: 'NormalizedUri',\n  NODEJS: NODEJS,\n  ORACLE: ORACLE,\n  POSTGRES: POSTGRES,\n  QUEUETIME: 'WebFrontend/QueueTime',\n  REDIS: REDIS,\n  RESTIFY: RESTIFY,\n  SUPPORTABILITY: SUPPORTABILITY,\n  TRANSACTION_ERROR: TRANSACTION_ERROR,\n  TRUNCATED: TRUNCATED,\n  URI: 'Uri',\n  UTILIZATION: UTILIZATION,\n  VIEW: VIEW,\n  WEB: WEB\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/feature_flags.js":"'use strict'\n\n// unreleased flags gating an active feature\nexports.prerelease = {\n  cat: true,\n  custom_instrumentation: true,\n  custom_metrics: true,\n  express5: false,\n  synthetics: true,\n  express_segments: true,\n  native_metrics: true,\n  promise_segments: false,\n  reverse_naming_rules: true,\n  send_request_uri_attribute: false\n}\n\n// flags that are no longer used for released features\nexports.released = [\n  'released',\n  'express4',\n  'insights',\n  'postgres',\n  'mysql_pool',\n  'proxy',\n  'custom_events'\n]\n\n// flags that are no longer used for unreleased features\nexports.unreleased = [\n  'unreleased'\n]\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/util/flatten.js":"'use strict'\n\n/**\n * Flatten nested maps of JSONifiable data.\n *\n * Ex: {a: 5, b: {c: true, d: 7}} -> {a: 5, 'b.c': true, 'b.d': 7}\n *\n * @param result Object to place key-value pairs into, normally called with {}\n * @param prefix Prefix for keys, normally called with ''\n * @param obj    Object to be flattened\n *\n * @return Object with flattened key-value pairs\n */\nmodule.exports = function flatten(result, prefix, obj, seen) {\n  seen = seen || []\n  seen.push(obj)\n\n  for (var key in obj) {\n    if (seen.indexOf(obj[key]) > -1) {\n      continue\n    }\n\n    if (obj[key] instanceof Object) flatten(result, prefix + key + '.', obj[key], seen)\n    else result[prefix + key] = obj[key]\n  }\n\n  return result\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/util/hashes.js":"'use strict'\n\nvar crypto = require('crypto')\n\nfunction encode(bytes, keyBytes) {\n  for (var i = 0; i < bytes.length; i++) {\n    // This is really dense but happens commonly so I'm in-lining some of what\n    // could be tossed into variables. It takes the current byte of bytes, then\n    // XORs it with the current byte of the key (which uses modulo to make sure\n    // to not overrun the end.)\n    bytes.writeUInt8(bytes.readUInt8(i) ^ keyBytes.readUInt8(i % keyBytes.length), i)\n  }\n  return bytes\n}\n\nfunction obfuscateNameUsingKey(name, key) {\n  var encodedBytes = new Buffer(name, 'utf-8')\n  var keyBytes = new Buffer(key)\n  return encode(encodedBytes, keyBytes).toString('base64')\n}\n\nfunction deobfuscateNameUsingKey(name, key) {\n  var bytes = new Buffer(name, 'base64')\n  var keyBytes = new Buffer(key)\n\n  return encode(bytes, keyBytes).toString(\"utf-8\")\n}\n\nfunction calculatePathHash(appName, pathName, referingPathHash) {\n  if (typeof referingPathHash === 'string') {\n    referingPathHash = parseInt(referingPathHash, 16)\n  }\n  var rotated = ((referingPathHash << 1) | (referingPathHash >>> 31)) >>> 0\n  var hash = getHash(appName, pathName)\n\n  var result = (rotated ^ hash) >>> 0\n\n  // This is a trick to pad it out to 8 chars regardless of length.\n  var retval = ('00000000' + result.toString(16)).substr(-8)\n\n  return retval\n}\n\nfunction getHash(appName, txName) {\n  var md5sum = crypto.createHash('md5')\n  md5sum.update(new Buffer(appName + ';' + txName), 'utf8')\n  var buf = new Buffer(md5sum.digest('base64'), 'base64')\n  // pull the low 4 bytes in network byte order\n  return buf.slice(buf.length - 4, buf.length).readUInt32BE(0)\n}\n\nexports.obfuscateNameUsingKey = obfuscateNameUsingKey\nexports.deobfuscateNameUsingKey = deobfuscateNameUsingKey\nexports.calculatePathHash = calculatePathHash\nexports.getHash = getHash\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/config.default.js":"'use strict'\n\n/**\n * This file includes all of the configuration variables used by the Node.js\n * module. If there's a configurable element of the module and it's not\n * described in here, there's been a terrible mistake.\n */\nexports.config = {\n  /**\n   * Array of application names.\n   *\n   * @env NEW_RELIC_APP_NAME\n   */\n  app_name: [],\n  /**\n   * The user's license key. Must be set by per-app configuration file.\n   *\n   * @env NEW_RELIC_LICENSE_KEY\n   */\n  license_key: '',\n  /**\n   * Hostname for the New Relic collector proxy.\n   *\n   * You shouldn't need to change this.\n   *\n   * @env NEW_RELIC_HOST\n   */\n  host: 'collector.newrelic.com',\n  /**\n   * The port on which the collector proxy will be listening.\n   *\n   * You shouldn't need to change this.\n   *\n   * @env NEW_RELIC_PORT\n   */\n  port: 443,\n  /**\n   * Whether or not to use SSL to connect to New Relic's servers.\n   *\n   * @env NEW_RELIC_USE_SSL\n   */\n  ssl: true,\n  /**\n   * Proxy url\n   *\n   * A proxy url can be used in place of setting\n   * proxy_host, proxy_port, proxy_user, and proxy_pass.\n   *\n   * e.g. http://user:pass@host:port/\n   *\n   * Setting proxy will override other proxy settings.\n   *\n   * @env NEW_RELIC_PROXY_URL\n   */\n  proxy: '',\n  /**\n   * Proxy host to use to connect to the internet.\n   *\n   * @env NEW_RELIC_PROXY_HOST\n   */\n  proxy_host: '',\n  /**\n   * Proxy port to use to connect to the internet.\n   *\n   * @env NEW_RELIC_PROXY_PORT\n   */\n  proxy_port: '',\n  /**\n   * Proxy user name when required.\n   *\n   * @env NEW_RELIC_PROXY_USER\n   */\n  proxy_user: '',\n  /**\n   * Proxy password when required.\n   *\n   * @env NEW_RELIC_PROXY_PASS\n   */\n  proxy_pass: '',\n  /**\n   * Custom SSL certificates\n   *\n   * If your proxy uses a custom SSL certificate, you can add the CA text to\n   * this array, one entry per certificate.\n   *\n   * The easiest way to do this is with `fs.readFileSync` e.g.\n   *\n   * certificates: [\n   *   require('fs').readFileSync('custom.crt', 'utf8') // don't forget the utf8\n   * ]\n   *\n   */\n  certificates: [],\n  /**\n   * You may want more control over how the module is configured and want to\n   * disallow the use of New Relic's server-side configuration. To do so, set\n   * this parameter to true. Some configuration information is required to make\n   * the module work properly with the rest of New Relic, but settings such as\n   * apdex_t and capture_params will not be override-able by New Relic with this\n   * setting in effect.\n   *\n   * @env NEW_RELIC_IGNORE_SERVER_CONFIGURATION\n   */\n  ignore_server_configuration: false,\n  /**\n   * Whether the module is enabled.\n   *\n   * @env NEW_RELIC_ENABLED\n   */\n  agent_enabled: true,\n  /**\n   * The default Apdex tolerating / threshold value for applications, in\n   * seconds. The default for Node is apdexT to 100 milliseconds, which is\n   * lower than New Relic standard, but Node.js applications tend to be more\n   * latency-sensitive than most.\n   *\n   * @env NEW_RELIC_APDEX\n   */\n  apdex_t: 0.100,\n  /**\n   * Whether to capture parameters in the request URL in slow transaction\n   * traces and error traces. Because this can pass sensitive data, it's\n   * disabled by default. If there are specific parameters you want ignored,\n   * use ignored_params.\n   *\n   * @env NEW_RELIC_CAPTURE_PARAMS\n   */\n  capture_params: false,\n  /**\n   * Array of parameters you don't want captured off request URLs in slow\n   * transaction traces and error traces.\n   *\n   * @env NEW_RELIC_IGNORED_PARAMS\n   */\n  ignored_params: [],\n  logging: {\n    /**\n     * Verbosity of the module's logging. This module uses bunyan\n     * (https://github.com/trentm/node-bunyan) for its logging, and as such the\n     * valid logging levels are 'fatal', 'error', 'warn', 'info', 'debug' and\n     * 'trace'. Logging at levels 'info' and higher is very terse. For support\n     * requests, attaching logs captured at 'trace' level are extremely helpful\n     * in chasing down bugs.\n     *\n     * @env NEW_RELIC_LOG_LEVEL\n     */\n    level: 'info',\n    /**\n     * Where to put the log file -- by default just uses process.cwd +\n     * 'newrelic_agent.log'. A special case is a filepath of 'stdout',\n     * in which case all logging will go to stdout, or 'stderr', in which\n     * case all logging will go to stderr.\n     *\n     * @env NEW_RELIC_LOG\n     */\n    filepath: require('path').join(process.cwd(), 'newrelic_agent.log'),\n    /**\n     * Whether to write to a log file at all\n     *\n     * @env NEW_RELIC_LOG_ENABLED\n     */\n    enabled: true,\n\n    /**\n     * Enables extra debugging at `warn` level. No need to enable except under\n     * specific debugging conditions.\n     */\n    diagnostics: false\n  },\n\n  audit_log: {\n\n    /**\n     * Enables logging of out bound traffic from the Agent to the Collector.\n     * This field is ignored if trace level logging is enabled.\n     * With trace logging, all traffic is logged.\n     *\n     * @env NEW_RELIC_AUDIT_LOG_ENABLED\n     */\n    enabled: false,\n\n    /**\n     * Specify which methods are logged. Used in conjuction with the audit_log flag\n     * If audit_log is enabled and this property is empty, all methods will be logged\n     * Otherwise, if the audit log is enabled, only the methods specified\n     * in the filter will be logged\n     * Methods include: error_data, metric_data, and analytic_event_data\n     *\n     * @env NEW_RELIC_AUDIT_LOG_ENDPOINTS\n     */\n    endpoints: []\n  },\n  /**\n   * Whether to collect & submit error traces to New Relic.\n   *\n   * @env NEW_RELIC_ERROR_COLLECTOR_ENABLED\n   */\n  error_collector: {\n    /**\n     * Disabling the error tracer just means that errors aren't collected\n     * and sent to New Relic -- it DOES NOT remove any instrumentation.\n     */\n    enabled: true,\n    /**\n     * List of HTTP error status codes the error tracer should disregard.\n     * Ignoring a status code means that the transaction is not renamed to\n     * match the code, and the request is not treated as an error by the error\n     * collector.\n     *\n     * NOTE: This configuration value has no effect on errors recorded using\n     * `noticeError()`.\n     *\n     * Defaults to 404 NOT FOUND.\n     *\n     * @env NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES\n     */\n    ignore_status_codes: [404],\n    /**\n     * Whether error events are collected.\n     */\n    capture_events: true,\n    /**\n     * The agent will collect all error events up to this number per minute.\n     * If there are more than that, a statistical sampling will be collected.\n     * Currently this uses a reservoir sampling algorithm.\n     *\n     * By increasing this setting you are both increasing the memory\n     * requirements of the agent as well as increasing the payload to the New\n     * Relic servers. The memory concerns are something you should consider for\n     * your own server's sake. The payload of events is compressed, but if it\n     * grows too large the New Relic servers may reject it.\n     */\n    max_event_samples_stored: 100\n  },\n  /**\n   * Options regarding collecting system information. Used for system\n   * utilization based pricing scheme.\n   */\n  utilization: {\n    /**\n     * This flag dictates whether the agent attempts to reach out to AWS\n     * to get info about the vm the process is running on.\n     *\n     * @env NEW_RELIC_UTILIZATION_DETECT_AWS\n     */\n    detect_aws: true,\n    /**\n     * This flag dictates whether the agent attempts to reach out to AWS\n     * to get info about the container the process is running in.\n     *\n     * @env NEW_RELIC_UTILIZATION_DETECT_DOCKER\n     */\n    detect_docker: true\n  },\n  transaction_tracer: {\n    /**\n     * Whether to collect & submit slow transaction traces to New Relic. The\n     * instrumentation is loaded regardless of this setting, as it's necessary\n     * to gather metrics. Disable the agent to prevent the instrumentation from\n     * loading.\n     *\n     * @env NEW_RELIC_TRACER_ENABLED\n     */\n    enabled: true,\n    /**\n     * The duration at below which the slow transaction tracer should collect a\n     * transaction trace. If set to 'apdex_f', the threshold will be set to\n     * 4 * apdex_t, which with a default apdex_t value of 500 milliseconds will\n     * be 2 seconds.\n     *\n     * If a time is provided, it is set in seconds.\n     *\n     * @env NEW_RELIC_TRACER_THRESHOLD\n     */\n    transaction_threshold: 'apdex_f',\n    /**\n     * Increase this parameter to increase the diversity of the slow\n     * transaction traces recorded by your application over time. Confused?\n     * Read on.\n     *\n     * Transactions are named based on the request (see the README for the\n     * details of how requests are mapped to transactions), and top_n refers to\n     * the \"top n slowest transactions\" grouped by these names. The module will\n     * only replace a recorded trace with a new trace if the new trace is\n     * slower than the previous slowest trace of that name. The default value\n     * for this setting is 20, as the transaction trace view page also defaults\n     * to showing the 20 slowest transactions.\n     *\n     * If you want to record the absolute slowest transaction over the last\n     * minute, set top_n to 0 or 1. This used to be the default, and has a\n     * problem in that it will allow one very slow route to dominate your slow\n     * transaction traces.\n     *\n     * The module will always record at least 5 different slow transactions in\n     * the reporting periods after it starts up, and will reset its internal\n     * slow trace aggregator if no slow transactions have been recorded for the\n     * last 5 harvest cycles, restarting the aggregation process.\n     *\n     * @env NEW_RELIC_TRACER_TOP_N\n     */\n    top_n: 20,\n\n    /**\n     * This option affects both slow-queries and record_sql for transaction\n     * traces.  It can have one of 3 values: 'off', 'obfuscated' or 'raw'\n     * When it is 'off' no slow queries will be captured, and backtraces\n     * and sql will not be included in transaction traces.  If it is 'raw'\n     * or 'obfuscated' and other criteria (slow_sql.enabled etc) are met\n     * for a query. The raw or obfuscated sql will be included in the\n     * transaction trace and a slow query sample will be collected.\n     */\n    record_sql: 'off',\n\n    /**\n     * This option affects both slow-queries and record_sql for transaction\n     * traces.  This is the minimum duration a query must take (in ms) for it\n     * to be considered for for slow query and inclusion in transaction traces.\n     */\n    explain_threshold: 500\n  },\n  /**\n   * Whether to enable internal supportability metrics and diagnostics. You're\n   * welcome to turn these on, but they will probably be most useful to the\n   * New Relic node engineering team.\n   */\n  debug: {\n    /**\n     * Whether to collect and submit internal supportability metrics alongside\n     * application performance metrics.\n     *\n     * @env NEW_RELIC_DEBUG_METRICS\n     */\n    internal_metrics: false,\n    /**\n     * Traces the execution of the transaction tracer. Requires logging.level\n     * to be set to 'trace' to provide any useful output.\n     *\n     * WARNING: The tracer tracing data is likely only to be intelligible to a\n     * small number of people inside New Relic, so you should probably only\n     * enable tracer tracing if asked to by New Relic, because it will affect\n     * performance significantly.\n     *\n     * @env NEW_RELIC_DEBUG_TRACER\n     */\n    tracer_tracing: false\n  },\n  /**\n   * Rules for naming or ignoring transactions.\n   */\n  rules: {\n    /**\n     * A list of rules of the format {pattern: 'pattern', name: 'name'} for\n     * matching incoming request URLs and naming the associated New Relic\n     * transactions. Both pattern and name are required. Additional attributes\n     * are ignored. Patterns may have capture groups (following JavaScript\n     * conventions), and names will use $1-style replacement strings. See\n     * the documentation for addNamingRule for important caveats.\n     *\n     * @env NEW_RELIC_NAMING_RULES\n     */\n    name: [],\n    /**\n     * A list of patterns for matching incoming request URLs to be ignored by\n     * the agent. Patterns may be strings or regular expressions.\n     *\n     * By default, socket.io long-polling is ignored.\n     *\n     * @env NEW_RELIC_IGNORING_RULES\n     */\n    ignore: [\n      '^\\/socket\\.io\\/.*\\/xhr-polling/'\n    ]\n  },\n  /**\n   * By default, any transactions that are not affected by other bits of\n   * naming logic (the API, rules, or metric normalization rules) will\n   * have their names set to 'NormalizedUri/*'. Setting this value to\n   * false will set them instead to Uri/path/to/resource. Don't change\n   * this setting unless you understand the implications of New Relic's\n   * metric grouping issues and are confident your application isn't going\n   * to run afoul of them. Your application could end up getting black holed!\n   * Nobody wants that.\n   *\n   * @env NEW_RELIC_ENFORCE_BACKSTOP\n   */\n  enforce_backstop: true,\n  /**\n   * Browser Monitoring\n   *\n   * Browser monitoring lets you correlate transactions between the server and browser\n   * giving you accurate data on how long a page request takes, from request,\n   * through the server response, up until the actual page render completes.\n   */\n  browser_monitoring: {\n\n    /**\n     * Enable browser monitoring header generation.\n     *\n     * This does not auto-instrument, rather it enables the agent to generate headers.\n     * The newrelic module can generate the appropriate <script> header, but you must\n     * inject the header yourself, or use a module that does so.\n     *\n     * Usage:\n     *\n     *     var newrelic = require('newrelic');\n     *\n     *     router.get('/', function (req, res) {\n     *       var header = newrelic.getBrowserTimingHeader();\n     *       res.write(header)\n     *       // write the rest of the page\n     *     });\n     *\n     * This generates the <script>...</script> header necessary for Browser Monitoring\n     * This script must be manually injected into your templates, as high as possible\n     * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.\n     * Otherwise you may hurt IE!\n     *\n     * This method must be called _during_ a transaction, and must be called every\n     * time you want to generate the headers.\n     *\n     * Do *not* reuse the headers between users, or even between requests.\n     *\n     * @env NEW_RELIC_BROWSER_MONITOR_ENABLE\n     */\n    enable: true,\n\n    /**\n     * Request un-minified sources from the server.\n     *\n     * @env NEW_RELIC_BROWSER_MONITOR_DEBUG\n     */\n    debug: false\n  },\n  /**\n   * Transaction Events\n   *\n   * Transaction events are sent to New Relic Insights. This event data\n   * includes transaction timing, transaction name, and any custom parameters.\n   *\n   * Read more here: http://newrelic.com/insights\n   */\n  transaction_events: {\n    /**\n     * If this is disabled, the agent does not collect, nor try to send,\n     * analytic data.\n     */\n    enabled: true,\n\n    /**\n     * The agent will collect all events up to this number per minute. If\n     * there are more than that, a statistical sampling will be collected.\n     */\n    max_samples_per_minute: 10000,\n\n    /**\n     * This is used if the agent is unable to send events to the collector.\n     * The values from the previous harvest cycle will be merged into the next\n     * one with this option as the limit.\n     *\n     * This should be *greater* than max_samples_per_minute or you'll see odd\n     * behavior. You probably want at least double the value, but more is okay\n     * as long as you can handle the memory overhead.\n     */\n    max_samples_stored: 20000\n  },\n\n  /**\n   * Custom Insights Events\n   *\n   * Custom insights events are JSON object that are sent to New Relic\n   * Insights. You can tell the agent to send your custom events via the\n   * `newrelic.recordCustomEvent()` API. These events are sampled once the max\n   * reservoir size is reached. You can tune this setting below.\n   *\n   * Read more here: http://newrelic.com/insights\n   */\n  custom_insights_events: {\n    /**\n     * If this is disabled, the agent does not collect, nor try to send, custom\n     * event data.\n     */\n    enabled: true,\n    /**\n     * The agent will collect all events up to this number per minute. If there\n     * are more than that, a statistical sampling will be collected. Current\n     * this uses a reservoir sampling algorithm.\n     *\n     * By increasing this setting you are both increasing the memory\n     * requirements of the agent as well as increasing the payload to the New\n     * Relic servers. The memory concerns are something you should consider for\n     * your own server's sake. The payload of events is compressed, but if it\n     * grows too large the New Relic servers may reject it.\n     */\n    max_samples_stored: 1000\n  },\n  /**\n   * This is used to configure properties about the user's host name.\n   */\n  process_host: {\n     /**\n     * Configurable display name for hosts\n     *\n     * @env NEW_RELIC_PROCESS_HOST_DISPLAY_NAME\n     */\n    display_name: '',\n    /**\n     * ip address preference when creating hostnames\n     *\n     * @env NEW_RELIC_IPV_PREFERENCE\n     */\n    ipv_preference: '4'\n },\n\n\n  /**\n   * High Security\n   *\n   * High security mode (v2) is a setting which prevents any sensitive data from\n   * being sent to New Relic. The local setting must match the server setting.\n   * If there is a mismatch the agent will log a message and act as if it is\n   * disabled.\n   *\n   * Attributes of high security mode (when enabled):\n   *  * requires SSL\n   *  * does not allow capturing of http params\n   *  * does not allow custom params\n   *\n   * To read more see: https://docs.newrelic.com/docs/subscriptions/high-security\n   */\n  high_security: false,\n\n  /**\n   * Labels\n   *\n   * An object of label names and values that will be applied to the data sent\n   * from this agent. Both label names and label values have a maximum length of\n   * 255 characters. This object should contain at most 64 labels.\n   */\n  labels: {},\n\n  /**\n   * These options control behavior for slow queries, but do not affect sql\n   * nodes in transaction traces.\n   * slow_sql.enabled enables and disables slow_sql recording\n   * slow_sql.max_samples sets the maximum number of slow query samples that\n   * will be collected in a single harvest cycle.\n   */\n   slow_sql: {\n    enabled: false,\n    max_samples: 10\n  },\n\n  /**\n   * Controls behavior of datastore instance metrics.\n   *\n   * @property {bool} [instance_reporting.enabled=true]\n   *  Enables reporting the host and port/path/id of database servers. Default\n   *  is `true`.\n   *\n   * @property {bool} [database_name_reporting.enabled=true]\n   *  Enables reporting of database/schema names. Default is `true`.\n   */\n  datastore_tracer: {\n    instance_reporting: {enabled: true},\n    database_name_reporting: {enabled: true}\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/node_modules/semver/semver.js":"exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id;\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num;\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  this.raw = this.version;\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<';\n        if (xm)\n          M = +M + 1;\n        else\n          m = +m + 1;\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.minSatisfying = minSatisfying;\nfunction minSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return compare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexports.prerelease = prerelease;\nfunction prerelease(version, loose) {\n  var parsed = parse(version, loose);\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null;\n}\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/stub_api.js":"'use strict'\n\nvar logger = require('./lib/logger.js')\nvar RealAPI = require('./api.js')\n\n\n/* eslint-disable no-eval */\nfunction stubFunction(name) {\n  return eval(\"(function () {return function \" + name + \"() {\" +\n              \"logger.debug('Not calling \" + name + \" because New Relic is disabled.');\" +\n              \"}}())\")\n}\n/* eslint-enable no-eval */\n\nfunction Stub() {}\n\nvar keys = Object.keys(RealAPI.prototype)\nvar length = keys.length\n\n\n/* This way the stub API doesn't have to be updated in lockstep with the regular\n * API.\n */\nfor (var i = 0; i < length; i++) {\n  var functionName = keys[i]\n  Stub.prototype[functionName] = stubFunction(functionName)\n}\n\nStub.prototype.createTracer = createTracer\nStub.prototype.createWebTransaction = createWebTransaction\nStub.prototype.createBackgroundTransaction = createBackgroundTransaction\nStub.prototype.getBrowserTimingHeader = getBrowserTimingHeader\nStub.prototype.shutdown = shutdown\n\n// This code gets injected into HTML templates\n// and we don't want it to return undefined/null.\nfunction getBrowserTimingHeader() {\n  logger.debug('Not calling getBrowserTimingHeader because New Relic is disabled.')\n  return ''\n}\n\n// Normally the following 3 calls return a wrapped callback, instead we\n// should just return the callback in its unwrapped state.\nfunction createTracer(name, callback) {\n  logger.debug('Not calling createTracer because New Relic is disabled.')\n  return callback\n}\n\nfunction createWebTransaction(url, callback) {\n  logger.debug('Not calling createWebTransaction because New Relic is disabled.')\n  return callback\n}\n\nfunction createBackgroundTransaction(name, group, callback) {\n  logger.debug('Not calling createBackgroundTransaction because New Relic is disabled.')\n  return (callback === undefined) ? group : callback\n}\n\n// Normally the following call executes callback asynchronously\nfunction shutdown(options, cb) {\n  logger.debug('Not calling shutdown because New Relic is disabled.')\n  \n  var callback = cb\n  if (!callback) {\n    if (typeof options === 'function') {\n      callback = options\n    } else {\n      callback = new Function()\n    }\n  }\n  \n  process.nextTick(callback)\n}\n\nmodule.exports = Stub\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/api.js":"'use strict'\n\nvar util = require('util')\nvar logger = require('./lib/logger').child({component: 'api'})\nvar NAMES = require('./lib/metrics/names')\nvar recordWeb = require('./lib/metrics/recorders/http.js')\nvar recordBackground = require('./lib/metrics/recorders/other.js')\nvar customRecorder = require('./lib/metrics/recorders/custom')\nvar hashes = require('./lib/util/hashes')\nvar stringify = require('json-stringify-safe')\n\n\n/*\n *\n * CONSTANTS\n *\n */\nvar RUM_STUB = \"<script type='text/javascript'>window.NREUM||(NREUM={});\" +\n                \"NREUM.info = %s; %s</script>\"\n\n// these messages are used in the _gracefail() method below in getBrowserTimingHeader\nvar RUM_ISSUES = [\n  'NREUM: no browser monitoring headers generated; disabled',\n  'NREUM: transaction missing while generating browser monitoring headers',\n  'NREUM: config.browser_monitoring missing, something is probably wrong',\n  'NREUM: browser_monitoring headers need a transaction name',\n  'NREUM: browser_monitoring requires valid application_id',\n  'NREUM: browser_monitoring requires valid browser_key',\n  'NREUM: browser_monitoring requires js_agent_loader script',\n  'NREUM: browser_monitoring disabled by browser_monitoring.loader config'\n]\n\n// can't overwrite internal parameters or all heck will break loose\nvar CUSTOM_BLACKLIST = [\n  'nr_flatten_leading'\n]\n\nvar CUSTOM_EVENT_TYPE_REGEX = /^[a-zA-Z0-9:_ ]+$/\n\n/**\n * The exported New Relic API. This contains all of the functions meant to be\n * used by New Relic customers. For now, that means transaction naming.\n */\nfunction API(agent) {\n  this.agent = agent\n}\n\n/**\n * Give the current transaction a custom name. Overrides any New Relic naming\n * rules set in configuration or from New Relic's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. New\n * Relic transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name The name you want to give the web request in the New\n *                      Relic UI. Will be prefixed with 'Custom/' when sent.\n */\nAPI.prototype.setTransactionName = function setTransactionName(name) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setTransactionName'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting name to '%s'.\", name)\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\"Must include name in setTransactionName call for URL %s.\",\n                   transaction.url)\n    } else {\n      logger.error(\"Must include name in setTransactionName call.\")\n    }\n\n    return\n  }\n\n  transaction.forceName = NAMES.CUSTOM + '/' + name\n}\n\n/**\n * Give the current transaction a name based on your own idea of what\n * constitutes a controller in your Node application. Also allows you to\n * optionally specify the action being invoked on the controller. If the action\n * is omitted, then the API will default to using the HTTP method used in the\n * request (e.g. GET, POST, DELETE). Overrides any New Relic naming rules set\n * in configuration or from New Relic's servers.\n *\n * IMPORTANT: this function must be called when a transaction is active. New\n * Relic transactions are tied to web requests, so this method may be called\n * from within HTTP or HTTPS listener functions, Express routes, or other\n * contexts where a web request or response object are in scope.\n *\n * @param {string} name   The name you want to give the controller in the New\n *                        Relic UI. Will be prefixed with 'Controller/' when\n *                        sent.\n * @param {string} action The action being invoked on the controller. Defaults\n *                        to the HTTP method used for the request.\n */\nAPI.prototype.setControllerName = function setControllerName(name, action) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setControllerName'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found when setting controller to %s.\", name)\n  }\n\n  if (!name) {\n    if (transaction && transaction.url) {\n      logger.error(\"Must include name in setControllerName call for URL %s.\",\n                   transaction.url)\n    } else {\n      logger.error(\"Must include name in setControllerName call.\")\n    }\n\n    return\n  }\n\n  action = action || transaction.verb || 'GET'\n  transaction.forceName = NAMES.CONTROLLER + '/' + name + '/' + action\n}\n\n/**\n * Add a custom parameter to the current transaction. Some parameters are\n * reserved (see CUSTOM_BLACKLIST for the current, very short list), and\n * as with most API methods, this must be called in the context of an\n * active transaction. Most recently set value wins.\n *\n * @param {string} name  The name you want displayed in the RPM UI.\n * @param {string} value The value you want displayed. Must be serializable.\n */\nAPI.prototype.addCustomParameter = function addCustomParameter(name, value) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addCustomParameter'\n  )\n  metric.incrementCallCount()\n\n  // If high security mode is on, custom params are disabled.\n  if (this.agent.config.high_security === true) {\n    logger.warnOnce(\n      \"Custom params\",\n      \"Custom parameters are disabled by high security mode.\"\n    )\n    return false\n  }\n\n  var ignored = this.agent.config.ignored_params || []\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found for custom parameters.\")\n  }\n\n  var trace = transaction.trace\n  if (!trace.custom) {\n    return logger.warn(\n      \"Couldn't add parameter %s to nonexistent custom parameters.\",\n      name\n    )\n  }\n\n  if (CUSTOM_BLACKLIST.indexOf(name) !== -1) {\n    return logger.warn(\"Not overwriting value of NR-only parameter %s.\", name)\n  }\n\n  if (ignored.indexOf(name) !== -1) {\n    return logger.warn(\"Not setting ignored parameter name %s.\", name)\n  }\n\n  if (name in trace.custom) {\n    logger.debug(\n      \"Changing custom parameter %s from %s to %s.\",\n      name,\n      trace.custom[name],\n      value\n    )\n  }\n\n  trace.custom[name] = value\n}\n\n/**\n * Adds all custom parameters in an object to the current transaction.\n *\n * See documentation for newrelic.addCustomParameter for more information on\n * setting custom parameters.\n *\n * An example of setting a custom parameter object:\n *\n *    newrelic.addCustomParameters({test: 'value', test2: 'value2'});\n *\n * @param {object} [params]\n * @param {string} [params.KEY] The name you want displayed in the RPM UI.\n * @param {string} [params.KEY.VALUE] The value you want displayed. Must be serializable.\n */\nAPI.prototype.addCustomParameters = function addCustomParameters(params) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addCustomParameters'\n  )\n  metric.incrementCallCount()\n\n  for (var key in params) {\n    if (!params.hasOwnProperty(key)) {\n      continue\n    }\n\n    this.addCustomParameter(key, params[key])\n  }\n}\n\n/**\n * Tell the tracer whether to ignore the current transaction. The most common\n * use for this will be to mark a transaction as ignored (maybe it's handling\n * a websocket polling channel, or maybe it's an external call you don't care\n * is slow), but it's also useful when you want a transaction that would\n * otherwise be ignored due to URL or transaction name normalization rules\n * to *not* be ignored.\n *\n * @param {boolean} ignored Ignore, or don't ignore, the current transaction.\n */\nAPI.prototype.setIgnoreTransaction = function setIgnoreTransaction(ignored) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/setIgnoreTransaction'\n  )\n  metric.incrementCallCount()\n\n  var transaction = this.agent.tracer.getTransaction()\n  if (!transaction) {\n    return logger.warn(\"No transaction found to ignore.\")\n  }\n\n  transaction.forceIgnore = ignored\n}\n\n/**\n * Send errors to New Relic that you've already handled yourself. Should be an\n * `Error` or one of its subtypes, but the API will handle strings and objects\n * that have an attached `.message` or `.stack` property.\n *\n * NOTE: Errors that are recorded using this method do _not_ obey the\n * `ignore_status_codes` configuration.\n *\n * @param {Error} error\n *  The error to be traced.\n *\n * @param {object} [customParameters]\n *  Optional. Any custom parameters to be displayed in the New Relic UI.\n */\nAPI.prototype.noticeError = function noticeError(error, customParameters) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/noticeError'\n  )\n  metric.incrementCallCount()\n\n\n  if (typeof error === 'string') error = new Error(error)\n  var transaction = this.agent.tracer.getTransaction()\n\n  this.agent.errors.addUserError(transaction, error, customParameters)\n}\n\n/**\n * If the URL for a transaction matches the provided pattern, name the\n * transaction with the provided name. If there are capture groups in the\n * pattern (which is a standard JavaScript regular expression, and can be\n * passed as either a RegExp or a string), then the substring matches ($1, $2,\n * etc.) are replaced in the name string. BE CAREFUL WHEN USING SUBSTITUTION.\n * If the replacement substrings are highly variable (i.e. are identifiers,\n * GUIDs, or timestamps), the rule will generate too many metrics and\n * potentially get your application blacklisted by New Relic.\n *\n * An example of a good rule with replacements:\n *\n *   newrelic.addNamingRule('^/storefront/(v[1-5])/(item|category|tag)',\n *                          'CommerceAPI/$1/$2')\n *\n * An example of a bad rule with replacements:\n *\n *   newrelic.addNamingRule('^/item/([0-9a-f]+)', 'Item/$1')\n *\n * Keep in mind that the original URL and any query parameters will be sent\n * along with the request, so slow transactions will still be identifiable.\n *\n * Naming rules can not be removed once added. They can also be added via the\n * agent's configuration. See configuration documentation for details.\n *\n * @param {RegExp} pattern The pattern to rename (with capture groups).\n * @param {string} name    The name to use for the transaction.\n */\nAPI.prototype.addNamingRule = function addNamingRule(pattern, name) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addNamingRule'\n  )\n  metric.incrementCallCount()\n\n\n  if (!name) return logger.error(\"Simple naming rules require a replacement name.\")\n\n  this.agent.userNormalizer.addSimple(pattern, '/' + name)\n}\n\n/**\n * If the URL for a transaction matches the provided pattern, ignore the\n * transaction attached to that URL. Useful for filtering socket.io connections\n * and other long-polling requests out of your agents to keep them from\n * distorting an app's apdex or mean response time. Pattern may be a (standard\n * JavaScript) RegExp or a string.\n *\n * Example:\n *\n *   newrelic.addIgnoringRule('^/socket\\\\.io/')\n *\n * @param {RegExp} pattern The pattern to ignore.\n */\nAPI.prototype.addIgnoringRule = function addIgnoringRule(pattern) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/addIgnoringRule'\n  )\n  metric.incrementCallCount()\n\n  if (!pattern) return logger.error(\"Must include a URL pattern to ignore.\")\n\n  this.agent.userNormalizer.addSimple(pattern, null)\n}\n\n/**\n * Get the <script>...</script> header necessary for Browser Monitoring\n * This script must be manually injected into your templates, as high as possible\n * in the header, but _after_ any X-UA-COMPATIBLE HTTP-EQUIV meta tags.\n * Otherwise you may hurt IE!\n *\n * This method must be called _during_ a transaction, and must be called every\n * time you want to generate the headers.\n *\n * Do *not* reuse the headers between users, or even between requests.\n *\n * @returns {string} the <script> header to be injected\n */\nAPI.prototype.getBrowserTimingHeader = function getBrowserTimingHeader() {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/getBrowserTimingHeader'\n  )\n  metric.incrementCallCount()\n\n  var config = this.agent.config\n\n  /**\n   * Gracefully fail.\n   *\n   * Output an HTML comment and log a warning the comment is meant to be\n   * innocuous to the end user.\n   *\n   * @param {number} num          - Error code from `RUM_ISSUES`.\n   * @param {bool} [quite=false]  - Be quiet about this failure.\n   *\n   * @see RUM_ISSUES\n   */\n  function _gracefail(num, quiet) {\n    if (quiet) {\n      logger.debug(RUM_ISSUES[num])\n    } else {\n      logger.warn(RUM_ISSUES[num])\n    }\n    return '<!-- NREUM: (' + num + ') -->'\n  }\n\n  var browser_monitoring = config.browser_monitoring\n\n  // config.browser_monitoring should always exist, but we don't want the agent\n  // to bail here if something goes wrong\n  if (!browser_monitoring) return _gracefail(2)\n\n  /* Can control header generation with configuration this setting is only\n   * available in the newrelic.js config file, it is not ever set by the\n   * server.\n   */\n  if (!browser_monitoring.enable) {\n    // It has been disabled by the user; no need to warn them about their own\n    // settings so fail quietly and gracefully.\n    return _gracefail(0, true)\n  }\n\n  var trans = this.agent.getTransaction()\n\n  // bail gracefully outside a transaction\n  if (!trans) return _gracefail(1)\n\n  var name = trans.getName()\n\n  /* If we're in an unnamed transaction, add a friendly warning this is to\n   * avoid people going crazy, trying to figure out why browser monitoring is\n   * not working when they're missing a transaction name.\n   */\n  if (!name) return _gracefail(3)\n\n  var time = trans.timer.getDurationInMillis()\n\n  /*\n   * Only the first 13 chars of the license should be used for hashing with\n   * the transaction name.\n   */\n  var key = config.license_key.substr(0, 13)\n  var appid = config.application_id\n\n  /* This is only going to work if the agent has successfully handshaked with\n   * the collector. If the networks is bad, or there is no license key set in\n   * newrelis.js, there will be no application_id set.  We bail instead of\n   * outputting null/undefined configuration values.\n   */\n  if (!appid) return _gracefail(4)\n\n  /* If there is no browser_key, the server has likely decided to disable\n   * browser monitoring.\n   */\n  var licenseKey = browser_monitoring.browser_key\n  if (!licenseKey) return _gracefail(5)\n\n  /* If there is no agent_loader script, there is no point\n   * in setting the rum data\n   */\n  var js_agent_loader = browser_monitoring.js_agent_loader\n  if (!js_agent_loader) return _gracefail(6)\n\n  /* If rum is enabled, but then later disabled on the server,\n   * this is the only parameter that gets updated.\n   *\n   * This condition should only be met if rum is disabled during\n   * the lifetime of an application, and it should be picked up\n   * on the next ForceRestart by the collector.\n   */\n  var loader = browser_monitoring.loader\n  if (loader === 'none') return _gracefail(7)\n\n  // This hash gets written directly into the browser.\n  var rum_hash = {\n    agent: browser_monitoring.js_agent_file,\n    beacon: browser_monitoring.beacon,\n    errorBeacon: browser_monitoring.error_beacon,\n    licenseKey: licenseKey,\n    applicationID: appid,\n    applicationTime: time,\n    transactionName: hashes.obfuscateNameUsingKey(name, key),\n    queueTime: trans.queueTime,\n    ttGuid: trans.id,\n\n    // we don't use these parameters yet\n    agentToken: null\n  }\n\n  // if debugging, do pretty format of JSON\n  var tabs = config.browser_monitoring.debug ? 2 : 0\n  var json = JSON.stringify(rum_hash, null, tabs)\n\n\n  // the complete header to be written to the browser\n  var out = util.format(\n    RUM_STUB,\n    json,\n    js_agent_loader\n  )\n\n  logger.trace('generating RUM header', out)\n\n  return out\n}\n\n/**\n * This creates a new tracer with the passed in name. It then wraps the\n * callback and binds it to the current transaction and segment so any further\n * custom instrumentation as well as auto instrumentation will also be able to\n * find the current transaction and segment.\n */\nAPI.prototype.createTracer = function createTracer(name, callback) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/createTracer'\n  )\n  metric.incrementCallCount()\n\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return callback\n  }\n\n  var fail = false\n  if (!name) {\n    logger.warn('createTracer called without a name')\n    fail = true\n  }\n\n  if (typeof callback !== 'function') {\n    logger.warn('createTracer called with a callback arg that is not a function')\n    fail = true\n  }\n\n  if (fail) {\n    // If name is undefined but callback is defined we should make a best effort\n    // to return it so things don't crash.\n    return callback\n  }\n\n  var tracer = this.agent.tracer\n  var txn = tracer.getTransaction()\n  if (!txn) {\n    logger.debug(\n      'createTracer called with %s (%s) outside of a transaction, ' +\n        'unable to create tracer.',\n      name,\n      callback && callback.name\n    )\n    return callback\n  }\n\n  logger.debug(\n    'creating tracer %s (%s) on transaction %s.',\n    name,\n    callback && callback.name,\n    txn.id\n  )\n\n  var segment = tracer.createSegment(name, customRecorder)\n  segment.start()\n  return tracer.bindFunction(callback, segment, true)\n}\n\n/**\n * Creates a function that represents a web transaction. It does not start the\n * transaction automatically - the returned function needs to be invoked to start it.\n * Inside the handler function, the transaction must be ended by calling endTransaction().\n *\n * @example\n * var newrelic = require('newrelic')\n * var transaction = newrelic.createWebTransaction('/some/url/path', function() {\n *   // do some work\n *   newrelic.endTransaction()\n * })\n *\n * @param {string}    url       The URL of the transaction.  It is used to name and group\n                                related transactions in APM, so it should be a generic\n                                name and not iclude any variable parameters.\n * @param {Function}  handle    Function that represents the transaction work.\n */\nAPI.prototype.createWebTransaction = function createWebTransaction(url, handle) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/createWebTransaction'\n  )\n  metric.incrementCallCount()\n\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return handle\n  }\n\n  var fail = false\n  if (!url) {\n    logger.warn('createWebTransaction called without an url')\n    fail = true\n  }\n\n  if (typeof handle !== 'function') {\n    logger.warn('createWebTransaction called with a handle arg that is not a function')\n    fail = true\n  }\n\n  if (fail) {\n    // If name is undefined but handle is defined we should make a best effort\n    // to return it so things don't crash.\n    return handle\n  }\n\n  logger.debug(\n    'creating web transaction generator %s (%s).',\n    url,\n    handle && handle.name\n  )\n\n  var tracer = this.agent.tracer\n\n  return tracer.transactionNestProxy('web', function createWebSegment() {\n    var tx = tracer.getTransaction()\n\n    logger.debug(\n      'creating web transaction %s (%s) with transaction id: %s',\n      url,\n      handle && handle.name,\n      tx.id\n    )\n    tx.nameState.setName(NAMES.CUSTOM, null, NAMES.ACTION_DELIMITER, url)\n    tx.url = url\n    tx.applyUserNamingRules(tx.url)\n    tx.webSegment = tracer.createSegment(url, recordWeb)\n    tx.webSegment.start()\n\n    return tracer.bindFunction(handle, tx.webSegment).apply(this, arguments)\n  })\n}\n\n/**\n * Creates a function that represents a background transaction. It does not start the\n * transaction automatically - the returned function needs to be invoked to start it.\n * Inside the handler function, the transaction must be ended by calling endTransaction().\n *\n * @example\n * var newrelic = require('newrelic')\n * var transaction = newrelic.createBackgroundTransaction('myTransaction', function() {\n *   // do some work\n *   newrelic.endTransaction()\n * })\n *\n * @param {string}    name      The name of the transaction.  It is used to name and group\n                                related transactions in APM, so it should be a generic\n                                name and not iclude any variable parameters.\n * @param {string}    [group]   Optional, used for grouping background transactions in\n *                              APM.  For more information see:\n *                              https://docs.newrelic.com/docs/apm/applications-menu/monitoring/transactions-page#txn-type-dropdown\n * @param {Function}  handle    Function that represents the background work.\n */\nAPI.prototype.createBackgroundTransaction = createBackgroundTransaction\n\nfunction createBackgroundTransaction(name, group, handle) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/createBackgroundTransaction'\n  )\n  metric.incrementCallCount()\n\n  if (handle === undefined && typeof group === 'function') {\n    handle = group\n    group = 'Nodejs'\n  }\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return handle\n  }\n\n  var fail = false\n  if (!name) {\n    logger.warn('createBackgroundTransaction called without an url')\n    fail = true\n  }\n\n  if (typeof handle !== 'function') {\n    logger.warn(\n      'createBackgroundTransaction called with a handle arg that is not a function'\n    )\n    fail = true\n  }\n\n  if (fail) {\n    // If name is undefined but handle is defined we should make a best effort\n    // to return it so things don't crash.\n    return handle\n  }\n\n  logger.debug(\n    'creating background transaction generator %s:%s (%s)',\n    name,\n    group,\n    handle && handle.name\n  )\n\n  var tracer = this.agent.tracer\n\n  return tracer.transactionNestProxy('bg', function createBackgroundSegment() {\n    var tx = tracer.getTransaction()\n\n    logger.debug(\n      'creating background transaction %s:%s (%s) with transaction id: %s',\n      name,\n      group,\n      handle && handle.name,\n      tx.id\n    )\n\n    tx.setBackgroundName(name, group)\n    tx.bgSegment = tracer.createSegment(name, recordBackground)\n    tx.bgSegment.partialName = group\n    tx.bgSegment.start()\n\n    return tracer.bindFunction(handle, tx.bgSegment).apply(this, arguments)\n  })\n}\n\nAPI.prototype.endTransaction = function endTransaction() {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/endTransaction'\n  )\n  metric.incrementCallCount()\n\n  // FLAG: custom_instrumentation\n  if (!this.agent.config.feature_flag.custom_instrumentation) {\n    return\n  }\n\n  var tracer = this.agent.tracer\n  var tx = tracer.getTransaction()\n\n  if (tx) {\n    if (tx.webSegment) {\n      tx.setName(tx.url, 0)\n      tx.webSegment.markAsWeb(tx.url)\n      tx.webSegment.end()\n    } else if (tx.bgSegment) {\n      tx.bgSegment.end()\n    }\n    logger.debug('ending transaction with id: %s and name: %s', tx.id, tx.name)\n    tx.end()\n  } else {\n    logger.debug('endTransaction() called while not in a transaction.')\n  }\n}\n\nAPI.prototype.recordMetric = function recordMetric(name, value) {\n  var supportMetric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/recordMetric'\n  )\n  supportMetric.incrementCallCount()\n\n  // FLAG: custom_metrics\n  if (!this.agent.config.feature_flag.custom_metrics) {\n    return\n  }\n\n  if (typeof name !== 'string') {\n    logger.warn('Metric name must be a string')\n    return\n  }\n\n  var metric = this.agent.metrics.getOrCreateMetric(name)\n\n  if (typeof value === 'number') {\n    metric.recordValue(value)\n    return\n  }\n\n  if (typeof value !== 'object') {\n    logger.warn('Metric value must be either a number, or a metric object')\n    return\n  }\n\n  var stats = {}\n  var required = ['count', 'total', 'min', 'max', 'sumOfSquares']\n  var keyMap = {count: 'callCount'}\n\n  for (var i = 0, l = required.length; i < l; ++i) {\n    if (typeof value[required[i]] !== 'number') {\n      logger.warn('Metric object must include ' + required[i] + ' as a number')\n      return\n    }\n\n    var key = keyMap[required[i]] || required[i]\n    stats[key] = value[required[i]]\n  }\n\n  if (typeof value.totalExclusive === 'number') {\n    stats.totalExclusive = value.totalExclusive\n  } else {\n    stats.totalExclusive = value.total\n  }\n\n  metric.merge(stats)\n}\n\nAPI.prototype.incrementMetric = function incrementMetric(name, value) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/incrementMetric'\n  )\n  metric.incrementCallCount()\n\n  // FLAG: custom_metrics\n  if (!this.agent.config.feature_flag.custom_metrics) {\n    return\n  }\n\n  if (!value && value !== 0) {\n    value = 1\n  }\n\n  if (typeof value !== 'number' || value % 1 !== 0) {\n    logger.warn('Metric Increment value must be an integer')\n    return\n  }\n\n  this.recordMetric(name, {\n    count: value,\n    total: 0,\n    min: 0,\n    max: 0,\n    sumOfSquares: 0\n  })\n}\n\nAPI.prototype.recordCustomEvent = function recordCustomEvent(eventType, attributes) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/recordCustomEvent'\n  )\n  metric.incrementCallCount()\n\n  if (!this.agent.config.custom_insights_events.enabled) {\n    return\n  }\n  // Check all the arguments before bailing to give maximum information in a\n  // single invocation.\n  var fail = false\n\n  if (!eventType || typeof eventType !== 'string') {\n    logger.warn(\n      'recordCustomEvent requires a string for its first argument, got %s (%s)',\n      stringify(eventType),\n      typeof eventType\n    )\n    fail = true\n  } else if (!CUSTOM_EVENT_TYPE_REGEX.test(eventType)) {\n    logger.warn(\n      'recordCustomEvent eventType of %s is invalid, it must match /%s/',\n      eventType,\n      CUSTOM_EVENT_TYPE_REGEX.source\n    )\n    fail = true\n  } else if (eventType.length > 255) {\n    logger.warn(\n      'recordCustomEvent eventType must have a length less than 256, got %s (%s)',\n      eventType,\n      eventType.length\n    )\n    fail = true\n  }\n  // If they don't pass an attributes object, or the attributes argument is not\n  // an object, or if it is an object and but is actually an array, log a\n  // warning and set the fail bit.\n  if (!attributes || typeof attributes !== 'object' || Array.isArray(attributes)) {\n    logger.warn(\n      'recordCustomEvent requires an object for its second argument, got %s (%s)',\n      stringify(attributes),\n      typeof attributes\n    )\n    fail = true\n  } else if (_checkKeyLength(attributes, 255)) {\n    fail = true\n  }\n\n  if (fail) {\n    return\n  }\n\n  var instrinics = {\n    type: eventType,\n    timestamp: Date.now()\n  }\n\n  this.agent.customEvents.add([instrinics, attributes])\n}\n\n/**\n * Shuts down the agent.\n *\n * @param {object}  [options]                           object with shut down options\n * @param {boolean} [options.collectPendingData=false]  If true, the agent will send any\n *                                                      pending data to the collector\n *                                                      before shutting down.\n * @param {number}  [options.timeout]                   time in ms to wait before\n *                                                      shutting down\n * @param {function} [callback]                         callback function that runs when\n *                                                      agent stopped\n */\nAPI.prototype.shutdown = function shutdown(options, cb) {\n  var metric = this.agent.metrics.getOrCreateMetric(\n    NAMES.SUPPORTABILITY.API + '/shutdown'\n  )\n  metric.incrementCallCount()\n\n  var callback = cb\n  if (!callback) {\n    if (typeof options === 'function') {\n      callback = options\n    } else {\n      callback = function noop() {}\n    }\n  }\n\n  var agent = this.agent\n\n  function cb_harvest(error) {\n    if (error) {\n      logger.error(\n        error,\n        'An error occurred while running last harvest before shutdown.'\n      )\n    }\n    agent.stop(callback)\n  }\n\n  if (options && options.collectPendingData && agent._state !== 'started') {\n    if (typeof options.timeout === 'number') {\n      var shutdownTimeout = setTimeout(function shutdownTimeout() {\n        agent.stop(callback)\n      }, options.timeout)\n      // timer.unref only in 0.9+\n      if (shutdownTimeout.unref) {\n        shutdownTimeout.unref()\n      }\n    } else if (options.timeout) {\n      logger.warn(\n        'options.timeout should be of type \"number\". Got %s',\n        typeof options.timeout\n      )\n    }\n\n    agent.on('started', function shutdownHarvest() {\n      agent.harvest(cb_harvest)\n    })\n    agent.on('errored', function logShutdownError(error) {\n      agent.stop(callback)\n      if (error) {\n        logger.error(\n          error,\n          'The agent encountered an error after calling shutdown.'\n        )\n      }\n    })\n  } else if (options && options.collectPendingData) {\n    agent.harvest(cb_harvest)\n  } else {\n    agent.stop(callback)\n  }\n}\n\nfunction _checkKeyLength(object, maxLength) {\n  var keys = Object.keys(object)\n  var badKey = false\n  var len = keys.length\n  var key = '' // init to string because gotta go fast\n  for (var i = 0; i < len; i++) {\n    key = keys[i]\n    if (key.length > maxLength) {\n      logger.warn(\n        'recordCustomEvent requires keys to be less than 256 chars got %s (%s)',\n        key,\n        key.length\n      )\n      badKey = true\n    }\n  }\n  return badKey\n}\n\nmodule.exports = API\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/metrics/recorders/http.js":"'use strict'\n\nvar NAMES = require('../../metrics/names.js')\n\n// CONSTANTS\nvar TO_MILLIS = 1e3\n\nfunction recordWeb(segment, scope) {\n  // in web metrics, scope is required\n  if (!scope) return\n\n  var transaction = segment.transaction\n  // if there was a nested webTransaction use its recorder instead\n  if (transaction.webSegment && segment !== transaction.webSegment) return\n\n  var duration = segment.getDurationInMillis()\n  var totalTime = transaction.trace.getTotalTimeDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var partial = segment.partialName\n  var config = segment.transaction.agent.config\n  // named / key transaction support requires per-name apdexT\n  var keyApdexInMillis = config.web_transactions_apdex[scope] * TO_MILLIS || 0\n\n  transaction.measure(NAMES.WEB.RESPONSE_TIME, null, duration, exclusive)\n  transaction.measure(NAMES.WEB.TOTAL_TIME, null, totalTime, exclusive)\n  transaction.measure(NAMES.HTTP, null, duration, exclusive)\n  transaction.measure(scope, null, duration, exclusive)\n  transaction.measure(NAMES.WEB.TOTAL_TIME + '/' + partial, null, totalTime, exclusive)\n\n  if (transaction.queueTime > 0) {\n    transaction.measure(NAMES.QUEUETIME, null, transaction.queueTime)\n  }\n\n  if (transaction.incomingCatId) {\n    transaction.measure(\n        NAMES.CLIENT_APPLICATION + '/' + transaction.incomingCatId + \"/all\",\n        null,\n        transaction.catResponseTime\n      )\n  }\n  transaction._setApdex(NAMES.APDEX + '/' + partial, duration, keyApdexInMillis)\n  transaction._setApdex(NAMES.APDEX, duration, keyApdexInMillis)\n}\n\nmodule.exports = recordWeb\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/metrics/recorders/other.js":"'use strict'\n\nvar NAMES = require('../../metrics/names.js')\n\nfunction recordBackground(segment, scope) {\n  // if there was a nested otherTransaction use its recorder instead\n  var transaction = segment.transaction\n  if (transaction.bgSegment && segment !== transaction.bgSegment) return\n\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var totalTime = segment.transaction.trace.getTotalTimeDurationInMillis()\n  var group = segment.partialName\n  var name = group + '/' + segment.name\n\n  if (scope) {\n    transaction.measure(scope, null, duration, exclusive)\n    transaction.measure(\n      NAMES.BACKGROUND.TOTAL_TIME + '/' + name,\n      null,\n      totalTime,\n      exclusive\n    )\n  }\n  // rollup for background total time doesn't have `/all` where the response\n  // time version does.\n  transaction.measure(\n    NAMES.BACKGROUND.RESPONSE_TIME + '/all',\n    null,\n    duration,\n    exclusive\n  )\n  transaction.measure(NAMES.BACKGROUND.TOTAL_TIME, null, totalTime, exclusive)\n}\n\nmodule.exports = recordBackground\n","/home/travis/build/npmtest/node-npmtest-newrelic/newrelic/lib/metrics/recorders/custom.js":"'use strict'\n\nvar NAMES = require('../names')\n\nfunction record(segment, scope) {\n  var duration = segment.getDurationInMillis()\n  var exclusive = segment.getExclusiveDurationInMillis()\n  var transaction = segment.transaction\n  var name = NAMES.CUSTOM + NAMES.ACTION_DELIMITER + segment.name\n\n  if (scope) transaction.measure(name, scope, duration, exclusive)\n\n  transaction.measure(name, null, duration, exclusive)\n}\n\nmodule.exports = record\n"}